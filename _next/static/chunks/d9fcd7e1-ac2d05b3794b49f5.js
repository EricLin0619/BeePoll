"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[792],{92916:function(t,e,a){Object.defineProperty(e,"__esModule",{value:!0});var i=a(42223),n=a(80496),r=a(67060);a(67462);var o=a(42474),l=a(67172),s=a(95131),u=a(4285),d=a(37083),f=a(91094);function c(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function w(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach(function(a){if("default"!==a){var i=Object.getOwnPropertyDescriptor(t,a);Object.defineProperty(e,a,i.get?i:{enumerable:!0,get:function(){return t[a]}})}}),e.default=t,Object.freeze(e)}var g=w(i),h=c(r),m=c(o),b=w(l),p=c(d),y=c(f);let S=n.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),v=n.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),x=n.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),C=n.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function F(t){let e;if(n.Scalar.eq(t,v))e=await n.buildBn128();else if(n.Scalar.eq(t,S))e=await n.buildBls12381();else throw Error(`Curve not supported: ${n.Scalar.toString(t)}`);return e}async function E(t){let e;if(n.Scalar.eq(t,C))e=await n.buildBn128();else if(n.Scalar.eq(t,x))e=await n.buildBls12381();else throw Error(`Curve not supported: ${n.Scalar.toString(t)}`);return e}async function G(t){let e;let a=t.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(a)>=0)e=await n.buildBn128();else if(["BLS12381"].indexOf(a)>=0)e=await n.buildBls12381();else throw Error(`Curve not supported: ${t}`);return e}function B(t){return((4294901760&t)!=0?(t&=4294901760,16):0)|((4278255360&t)!=0?(t&=4278255360,8):0)|((4042322160&t)!=0?(t&=4042322160,4):0)|((3435973836&t)!=0?(t&=3435973836,2):0)|(2863311530&t)!=0}function _(t,e){let a=new DataView(t.buffer,t.byteOffset,t.byteLength),i="";for(let t=0;t<4;t++){t>0&&(i+="\n"),i+="		";for(let e=0;e<4;e++)e>0&&(i+=" "),i+=a.getUint32(16*t+4*e).toString(16).padStart(8,"0")}return e&&(i=e+"\n"+i),i}function T(t,e){if(t.byteLength!=e.byteLength)return!1;for(var a=new Int8Array(t),i=new Int8Array(e),n=0;n!=t.byteLength;n++)if(a[n]!=i[n])return!1;return!0}async function L(t,e,a,i,n){if(t.G1.isZero(e)||t.G1.isZero(a)||t.G2.isZero(i)||t.G2.isZero(n))return!1;let r=await t.pairingEq(e,n,t.G1.neg(a),i);return r}function A(t){let e=new Uint8Array(t);return void 0!==globalThis.crypto?globalThis.crypto.getRandomValues(e):m.default.randomFillSync(e),e}async function z(t){if(void 0===globalThis.crypto||void 0===globalThis.crypto.subtle)return m.default.createHash("sha256").update(t).digest();{let e=await globalThis.crypto.subtle.digest("SHA-256",t.buffer);return new Uint8Array(e)}}function P(t,e){return new DataView(t.buffer).getUint32(e,!1)}async function R(t){for(;!t;)t=await window.prompt("Enter a random text. (Entropy): ","");let e=h.default(64);e.update(A(64));let a=new TextEncoder;e.update(a.encode(t));let i=e.digest(),r=[];for(let t=0;t<8;t++)r[t]=P(i,4*t);let o=new n.ChaCha(r);return o}async function U(t,e){let a,i;e<32?(a=1<<e>>>0,i=1):(a=4294967296,i=1<<e-32>>>0);let r=t;for(let t=0;t<i;t++)for(let t=0;t<a;t++)r=await z(r);let o=new DataView(r.buffer,r.byteOffset,r.byteLength),l=[];for(let t=0;t<8;t++)l[t]=o.getUint32(4*t,!1);let s=new n.ChaCha(l);return s}function $(t){return t instanceof Uint8Array?t:("0x"==t.slice(0,2)&&(t=t.slice(2)),new Uint8Array(t.match(/[\da-f]{2}/gi).map(function(t){return parseInt(t,16)})))}function k(t){return Array.prototype.map.call(t,function(t){return("0"+(255&t).toString(16)).slice(-2)}).join("")}function I(t,e){if(e instanceof Uint8Array)return t.toString(e);if(Array.isArray(e))return e.map(I.bind(null,t));if("object"==typeof e){let a={},i=Object.keys(e);return i.forEach(i=>{a[i]=I(t,e[i])}),a}return"bigint"==typeof e||void 0!==e.eq?e.toString(10):e}async function O(t,e){await g.startWriteSection(t,1),await t.writeULE32(1),await g.endWriteSection(t);let a=await E(e.q);await g.startWriteSection(t,2);let i=a.q,r=(Math.floor((n.Scalar.bitLength(i)-1)/64)+1)*8,o=a.r,l=(Math.floor((n.Scalar.bitLength(o)-1)/64)+1)*8;await t.writeULE32(r),await g.writeBigInt(t,i,r),await t.writeULE32(l),await g.writeBigInt(t,o,l),await t.writeULE32(e.nVars),await t.writeULE32(e.nPublic),await t.writeULE32(e.domainSize),await q(t,a,e.vk_alpha_1),await q(t,a,e.vk_beta_1),await W(t,a,e.vk_beta_2),await W(t,a,e.vk_gamma_2),await q(t,a,e.vk_delta_1),await W(t,a,e.vk_delta_2),await g.endWriteSection(t)}async function q(t,e,a){let i=new Uint8Array(2*e.G1.F.n8);e.G1.toRprLEM(i,0,a),await t.write(i)}async function W(t,e,a){let i=new Uint8Array(2*e.G2.F.n8);e.G2.toRprLEM(i,0,a),await t.write(i)}async function M(t,e,a){let i=await t.read(2*e.G1.F.n8),n=e.G1.fromRprLEM(i,0);return a?e.G1.toObject(n):n}async function V(t,e,a){let i=await t.read(2*e.G2.F.n8),n=e.G2.fromRprLEM(i,0);return a?e.G2.toObject(n):n}async function N(t,e,a){await g.startReadUniqueSection(t,e,1);let i=await t.readULE32();if(await g.endReadSection(t),1===i)return await Q(t,e,a);if(2===i)return await j(t,e,a);if(10===i)return await H(t,e,a);throw Error("Protocol not supported: ")}async function Q(t,e,a){let i={};i.protocol="groth16",await g.startReadUniqueSection(t,e,2);let n=await t.readULE32();i.n8q=n,i.q=await g.readBigInt(t,n);let r=await t.readULE32();return i.n8r=r,i.r=await g.readBigInt(t,r),i.curve=await E(i.q),i.nVars=await t.readULE32(),i.nPublic=await t.readULE32(),i.domainSize=await t.readULE32(),i.power=B(i.domainSize),i.vk_alpha_1=await M(t,i.curve,a),i.vk_beta_1=await M(t,i.curve,a),i.vk_beta_2=await V(t,i.curve,a),i.vk_gamma_2=await V(t,i.curve,a),i.vk_delta_1=await M(t,i.curve,a),i.vk_delta_2=await V(t,i.curve,a),await g.endReadSection(t),i}async function j(t,e,a){let i={};i.protocol="plonk",await g.startReadUniqueSection(t,e,2);let n=await t.readULE32();i.n8q=n,i.q=await g.readBigInt(t,n);let r=await t.readULE32();return i.n8r=r,i.r=await g.readBigInt(t,r),i.curve=await E(i.q),i.nVars=await t.readULE32(),i.nPublic=await t.readULE32(),i.domainSize=await t.readULE32(),i.power=B(i.domainSize),i.nAdditions=await t.readULE32(),i.nConstraints=await t.readULE32(),i.k1=await t.read(r),i.k2=await t.read(r),i.Qm=await M(t,i.curve,a),i.Ql=await M(t,i.curve,a),i.Qr=await M(t,i.curve,a),i.Qo=await M(t,i.curve,a),i.Qc=await M(t,i.curve,a),i.S1=await M(t,i.curve,a),i.S2=await M(t,i.curve,a),i.S3=await M(t,i.curve,a),i.X_2=await V(t,i.curve,a),await g.endReadSection(t),i}async function H(t,e,a){let i={};i.protocol="fflonk",i.protocolId=10,await g.startReadUniqueSection(t,e,2);let n=await t.readULE32();i.n8q=n,i.q=await g.readBigInt(t,n),i.curve=await E(i.q);let r=await t.readULE32();return i.n8r=r,i.r=await g.readBigInt(t,r),i.nVars=await t.readULE32(),i.nPublic=await t.readULE32(),i.domainSize=await t.readULE32(),i.power=B(i.domainSize),i.nAdditions=await t.readULE32(),i.nConstraints=await t.readULE32(),i.k1=await t.read(r),i.k2=await t.read(r),i.w3=await t.read(r),i.w4=await t.read(r),i.w8=await t.read(r),i.wr=await t.read(r),i.X_2=await V(t,i.curve,a),i.C0=await M(t,i.curve,a),await g.endReadSection(t),i}async function Z(t,e){let{fd:a,sections:i}=await g.readBinFile(t,"zkey",1),r=await N(a,i,e),o=new n.F1Field(r.r),l=n.Scalar.mod(n.Scalar.shl(1,8*r.n8r),r.r),s=o.inv(l),u=o.mul(s,s),d=await E(r.q);await g.startReadUniqueSection(a,i,3),r.IC=[];for(let t=0;t<=r.nPublic;t++){let t=await M(a,d,e);r.IC.push(t)}await g.endReadSection(a),await g.startReadUniqueSection(a,i,4);let f=await a.readULE32();r.ccoefs=[];for(let t=0;t<f;t++){let t=await a.readULE32(),e=await a.readULE32(),i=await a.readULE32(),n=await c();r.ccoefs.push({matrix:t,constraint:e,signal:i,value:n})}await g.endReadSection(a),await g.startReadUniqueSection(a,i,5),r.A=[];for(let t=0;t<r.nVars;t++){let i=await M(a,d,e);r.A[t]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,6),r.B1=[];for(let t=0;t<r.nVars;t++){let i=await M(a,d,e);r.B1[t]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,7),r.B2=[];for(let t=0;t<r.nVars;t++){let i=await V(a,d,e);r.B2[t]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,8),r.C=[];for(let t=r.nPublic+1;t<r.nVars;t++){let i=await M(a,d,e);r.C[t]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,9),r.hExps=[];for(let t=0;t<r.domainSize;t++){let t=await M(a,d,e);r.hExps.push(t)}return await g.endReadSection(a),await a.close(),r;async function c(){let t=await g.readBigInt(a,r.n8r);return o.mul(t,u)}}async function D(t,e,a){let i={delta:{}};i.deltaAfter=await M(t,e,a),i.delta.g1_s=await M(t,e,a),i.delta.g1_sx=await M(t,e,a),i.delta.g2_spx=await V(t,e,a),i.transcript=await t.read(64),i.type=await t.readULE32();let n=await t.readULE32(),r=t.pos,o=0;for(;t.pos-r<n;){let e=await t.read(1);if(e[0]<=o)throw Error("Parameters in the contribution must be sorted");if(o=e[0],1==e[0]){let e=await t.read(1),a=await t.read(e[0]);i.name=new TextDecoder().decode(a)}else if(2==e[0]){let e=await t.read(1);i.numIterationsExp=e[0]}else if(3==e[0]){let e=await t.read(1);i.beaconHash=await t.read(e[0])}else throw Error("Parameter not recognized")}if(t.pos!=r+n)throw Error("Parametes do not match");return i}async function K(t,e,a){await g.startReadUniqueSection(t,a,10);let i={contributions:[]};i.csHash=await t.read(64);let n=await t.readULE32();for(let a=0;a<n;a++){let a=await D(t,e);i.contributions.push(a)}return await g.endReadSection(t),i}async function X(t,e,a){await q(t,e,a.deltaAfter),await q(t,e,a.delta.g1_s),await q(t,e,a.delta.g1_sx),await W(t,e,a.delta.g2_spx),await t.write(a.transcript),await t.writeULE32(a.type||0);let i=[];if(a.name){i.push(1);let t=new TextEncoder("utf-8").encode(a.name.substring(0,64));i.push(t.byteLength);for(let e=0;e<t.byteLength;e++)i.push(t[e])}if(1==a.type){i.push(2),i.push(a.numIterationsExp),i.push(3),i.push(a.beaconHash.byteLength);for(let t=0;t<a.beaconHash.byteLength;t++)i.push(a.beaconHash[t])}if(i.length>0){let e=new Uint8Array(i);await t.writeULE32(e.byteLength),await t.write(e)}else await t.writeULE32(0)}async function Y(t,e,a){await g.startWriteSection(t,10),await t.write(a.csHash),await t.writeULE32(a.contributions.length);for(let i=0;i<a.contributions.length;i++)await X(t,e,a.contributions[i]);await g.endWriteSection(t)}function J(t,e,a){let i=new Uint8Array(2*e.G1.F.n8);e.G1.toRprUncompressed(i,0,a),t.update(i)}function tt(t,e,a){J(t,e,a.deltaAfter),J(t,e,a.delta.g1_s),J(t,e,a.delta.g1_sx),function(t,e,a){let i=new Uint8Array(2*e.G2.F.n8);e.G2.toRprUncompressed(i,0,a),t.update(i)}(t,e,a.delta.g2_spx),t.update(a.transcript)}async function te(t,e,a){await g.startWriteSection(t,1);let i=(Math.floor((n.Scalar.bitLength(a)-1)/64)+1)*8;await t.writeULE32(i),await g.writeBigInt(t,a,i),await t.writeULE32(e.length),await g.endWriteSection(t),await g.startWriteSection(t,2);for(let a=0;a<e.length;a++)await g.writeBigInt(t,e[a],i);await g.endWriteSection(t,2)}async function ta(t,e,a){await g.startWriteSection(t,1);let i=(Math.floor((n.Scalar.bitLength(a)-1)/64)+1)*8;if(await t.writeULE32(i),await g.writeBigInt(t,a,i),e.byteLength%i!=0)throw Error("Invalid witness length");await t.writeULE32(e.byteLength/i),await g.endWriteSection(t),await g.startWriteSection(t,2),await t.write(e),await g.endWriteSection(t)}async function ti(t,e){await g.startReadUniqueSection(t,e,1);let a=await t.readULE32(),i=await g.readBigInt(t,a),n=await t.readULE32();return await g.endReadSection(t),{n8:a,q:i,nWitness:n}}async function tn(t){let{fd:e,sections:a}=await g.readBinFile(t,"wtns",2),{n8:i,nWitness:n}=await ti(e,a);await g.startReadUniqueSection(e,a,2);let r=[];for(let t=0;t<n;t++){let t=await g.readBigInt(e,i);r.push(t)}return await g.endReadSection(e),await e.close(),r}let{stringifyBigInts:tr}=n.utils;async function to(t,e,a){let{fd:i,sections:r}=await g.readBinFile(e,"wtns",2,33554432,8388608),o=await ti(i,r),{fd:l,sections:s}=await g.readBinFile(t,"zkey",2,33554432,8388608),u=await N(l,s);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=u.nVars)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}`);let d=u.curve,f=d.Fr,c=d.G1,w=d.G2,h=B(u.domainSize);a&&a.debug("Reading Wtns");let m=await g.readSection(i,r,2);a&&a.debug("Reading Coeffs");let b=await g.readSection(l,s,4);a&&a.debug("Building ABC");let[p,y,S]=await tl(d,u,m,b,a),v=h==f.s?d.Fr.shift:d.Fr.w[h+1],x=await f.ifft(p,"","",a,"IFFT_A"),C=await f.batchApplyKey(x,f.e(1),v),F=await f.fft(C,"","",a,"FFT_A"),E=await f.ifft(y,"","",a,"IFFT_B"),G=await f.batchApplyKey(E,f.e(1),v),_=await f.fft(G,"","",a,"FFT_B"),T=await f.ifft(S,"","",a,"IFFT_C"),L=await f.batchApplyKey(T,f.e(1),v),A=await f.fft(L,"","",a,"FFT_C");a&&a.debug("Join ABC");let z=await ts(d,u,F,_,A,a),P={};a&&a.debug("Reading A Points");let R=await g.readSection(l,s,5);P.pi_a=await d.G1.multiExpAffine(R,m,a,"multiexp A"),a&&a.debug("Reading B1 Points");let U=await g.readSection(l,s,6),$=await d.G1.multiExpAffine(U,m,a,"multiexp B1");a&&a.debug("Reading B2 Points");let k=await g.readSection(l,s,7);P.pi_b=await d.G2.multiExpAffine(k,m,a,"multiexp B2"),a&&a.debug("Reading C Points");let I=await g.readSection(l,s,8);P.pi_c=await d.G1.multiExpAffine(I,m.slice((u.nPublic+1)*d.Fr.n8),a,"multiexp C"),a&&a.debug("Reading H Points");let O=await g.readSection(l,s,9),q=await d.G1.multiExpAffine(O,z,a,"multiexp H"),W=d.Fr.random(),M=d.Fr.random();P.pi_a=c.add(P.pi_a,u.vk_alpha_1),P.pi_a=c.add(P.pi_a,c.timesFr(u.vk_delta_1,W)),P.pi_b=w.add(P.pi_b,u.vk_beta_2),P.pi_b=w.add(P.pi_b,w.timesFr(u.vk_delta_2,M)),$=c.add($,u.vk_beta_1),$=c.add($,c.timesFr(u.vk_delta_1,M)),P.pi_c=c.add(P.pi_c,q),P.pi_c=c.add(P.pi_c,c.timesFr(P.pi_a,M)),P.pi_c=c.add(P.pi_c,c.timesFr($,W)),P.pi_c=c.add(P.pi_c,c.timesFr(u.vk_delta_1,f.neg(f.mul(W,M))));let V=[];for(let t=1;t<=u.nPublic;t++){let e=m.slice(t*f.n8,t*f.n8+f.n8);V.push(n.Scalar.fromRprLE(e))}return P.pi_a=c.toObject(c.toAffine(P.pi_a)),P.pi_b=w.toObject(w.toAffine(P.pi_b)),P.pi_c=c.toObject(c.toAffine(P.pi_c)),P.protocol="groth16",P.curve=d.name,await l.close(),await i.close(),{proof:P=tr(P),publicSignals:V=tr(V)}}async function tl(t,e,a,i,r){let o=t.Fr.n8,l=12+e.n8r,s=(i.byteLength-4)/l,u=new n.BigBuffer(e.domainSize*o),d=new n.BigBuffer(e.domainSize*o),f=new n.BigBuffer(e.domainSize*o),c=[u,d];for(let e=0;e<s;e++){r&&e%1e6==0&&r.debug(`QAP AB: ${e}/${s}`);let n=i.slice(4+e*l,4+e*l+l),u=new DataView(n.buffer),d=u.getUint32(0,!0),f=u.getUint32(4,!0),w=u.getUint32(8,!0),g=n.slice(12,12+o);c[d].set(t.Fr.add(c[d].slice(f*o,f*o+o),t.Fr.mul(g,a.slice(w*o,w*o+o))),f*o)}for(let a=0;a<e.domainSize;a++)r&&a%1e6==0&&r.debug(`QAP C: ${a}/${e.domainSize}`),f.set(t.Fr.mul(u.slice(a*o,a*o+o),d.slice(a*o,a*o+o)),a*o);return[u,d,f]}async function ts(t,e,a,i,r,o){let l;let s=t.Fr.n8,u=Math.floor(a.byteLength/t.Fr.n8),d=[];for(let e=0;e<u;e+=4194304){o&&o.debug(`JoinABC: ${e}/${u}`);let n=Math.min(u-e,4194304),l=[],f=a.slice(e*s,(e+n)*s),c=i.slice(e*s,(e+n)*s),w=r.slice(e*s,(e+n)*s);l.push({cmd:"ALLOCSET",var:0,buff:f}),l.push({cmd:"ALLOCSET",var:1,buff:c}),l.push({cmd:"ALLOCSET",var:2,buff:w}),l.push({cmd:"ALLOC",var:3,len:n*s}),l.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:n},{var:3}]}),l.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:n},{var:3}]}),l.push({cmd:"GET",out:0,var:3,len:n*s}),d.push(t.tm.queueAction(l))}let f=await Promise.all(d);l=a instanceof n.BigBuffer?new n.BigBuffer(a.byteLength):new Uint8Array(a.byteLength);let c=0;for(let t=0;t<f.length;t++)l.set(f[t][0],c),c+=f[t][0].byteLength;return l}let{unstringifyBigInts:tu}=n.utils;async function td(t,e,a,i){let n=tu(t),r=await b.readExisting(e),o=await r.read(r.totalSize);await r.close();let l=await s.WitnessCalculatorBuilder(o);if(1==l.circom_version()){let t=await l.calculateBinWitness(n),e=await g.createBinFile(a,"wtns",2,2);await ta(e,t,l.prime),await e.close()}else{let t=await b.createOverride(a),e=await l.calculateWTNSBin(n);await t.write(e),await t.close()}}let{unstringifyBigInts:tf}=n.utils;async function tc(t,e,a,i){let n=tf(t),r={type:"mem"};return await td(n,e,r),await to(a,r,i)}let{unstringifyBigInts:tw}=n.utils;async function tg(t,e,a,i){let r=tw(t),o=tw(a),l=tw(e),s=await G(r.curve),u=s.G1.fromObject(r.IC[0]),d=new Uint8Array(2*s.G1.F.n8*l.length),f=new Uint8Array(s.Fr.n8*l.length);if(!function(t,e){for(let a=0;a<e.length;a++)if(!n.Scalar.lt(e[a],t.r))return!1;return!0}(s,l))return i&&i.error("Public inputs are not valid."),!1;for(let t=0;t<l.length;t++){let e=s.G1.fromObject(r.IC[t+1]);d.set(e,t*s.G1.F.n8*2),n.Scalar.toRprLE(f,s.Fr.n8*t,l[t],s.Fr.n8)}let c=await s.G1.multiExpAffine(d,f);c=s.G1.add(c,u);let w=s.G1.fromObject(o.pi_a),g=s.G2.fromObject(o.pi_b),h=s.G1.fromObject(o.pi_c);if(!function(t,e){let a=t.G1,i=t.G2;return a.isValid(e.pi_a)&&i.isValid(e.pi_b)&&a.isValid(e.pi_c)}(s,{pi_a:w,pi_b:g,pi_c:h}))return i&&i.error("Proof commitments are not valid."),!1;let m=s.G2.fromObject(r.vk_gamma_2),b=s.G2.fromObject(r.vk_delta_2),p=s.G1.fromObject(r.vk_alpha_1),y=s.G2.fromObject(r.vk_beta_2),S=await s.pairingEq(s.G1.neg(w),g,c,m,h,b,p,y);return S?(i&&i.info("OK!"),!0):(i&&i.error("Invalid proof"),!1)}let{unstringifyBigInts:th}=n.utils;function tm(t){let e=t.toString(16);for(;e.length<64;)e="0"+e;return`"0x${e}"`}var tb=Object.freeze({__proto__:null,fullProve:tc,prove:to,verify:tg,exportSolidityCallData:async function(t,e){let a=th(t),i=th(e),n="";for(let t=0;t<i.length;t++)""!=n&&(n+=","),n+=tm(i[t]);return`[${tm(a.pi_a[0])}, ${tm(a.pi_a[1])}],[[${tm(a.pi_b[0][1])}, ${tm(a.pi_b[0][0])}],[${tm(a.pi_b[1][1])}, ${tm(a.pi_b[1][0])}]],[${tm(a.pi_c[0])}, ${tm(a.pi_c[1])}],[${n}]`}});function tp(t,e){let a=new DataView(e.buffer,e.byteOffset,e.byteLength),i=[];for(let t=0;t<8;t++)i[t]=a.getUint32(4*t);let r=new n.ChaCha(i),o=t.G2.fromRng(r);return o}function ty(t,e,a,i,n){let r=h.default(64),o=new Uint8Array([e]);r.update(o),r.update(a);let l=t.G1.toUncompressed(i);r.update(l);let s=t.G1.toUncompressed(n);r.update(s);let u=r.digest();return tp(t,u)}function tS(t,e,a,i,n){return t.g1_s=e.G1.toAffine(e.G1.fromRng(n)),t.g1_sx=e.G1.toAffine(e.G1.timesFr(t.g1_s,t.prvKey)),t.g2_sp=e.G2.toAffine(ty(e,a,i,t.g1_s,t.g1_sx)),t.g2_spx=e.G2.toAffine(e.G2.timesFr(t.g2_sp,t.prvKey)),t}function tv(t,e,a){let i={tau:{},alpha:{},beta:{}};return i.tau.prvKey=t.Fr.fromRng(a),i.alpha.prvKey=t.Fr.fromRng(a),i.beta.prvKey=t.Fr.fromRng(a),tS(i.tau,t,0,e,a),tS(i.alpha,t,1,e,a),tS(i.beta,t,2,e,a),i}async function tx(t,e,a,i){i||(i=a),await t.writeULE32(1);let r=t.pos;await t.writeULE64(0),await t.writeULE32(8*e.F1.n64);let o=new Uint8Array(e.F1.n8);n.Scalar.toRprLE(o,0,e.q,e.F1.n8),await t.write(o),await t.writeULE32(a),await t.writeULE32(i);let l=t.pos-r-8,s=t.pos;await t.writeULE64(l,r),t.pos=s}async function tC(t,e){if(!e[1])throw Error(t.fileName+": File has no  header");if(e[1].length>1)throw Error(t.fileName+": File has more than one header");t.pos=e[1][0].p;let a=await t.readULE32(),i=await t.read(a),r=n.Scalar.fromRprLE(i),o=await E(r);if(8*o.F1.n64!=a)throw Error(t.fileName+": Invalid size");let l=await t.readULE32(),s=await t.readULE32();if(t.pos-e[1][0].p!=e[1][0].size)throw Error("Invalid PTau header size");return{curve:o,power:l,ceremonyPower:s}}async function tF(t,e,a){let i=await t.read(12*e.F1.n8+6*e.F2.n8);return tE(i,0,e,a)}function tE(t,e,a,i){let n={tau:{},alpha:{},beta:{}};return n.tau.g1_s=r(),n.tau.g1_sx=r(),n.alpha.g1_s=r(),n.alpha.g1_sx=r(),n.beta.g1_s=r(),n.beta.g1_sx=r(),n.tau.g2_spx=o(),n.alpha.g2_spx=o(),n.beta.g2_spx=o(),n;function r(){let n;return n=i?a.G1.fromRprLEM(t,e):a.G1.fromRprUncompressed(t,e),e+=2*a.G1.F.n8,n}function o(){let n;return n=i?a.G2.fromRprLEM(t,e):a.G2.fromRprUncompressed(t,e),e+=2*a.G2.F.n8,n}}function tG(t,e,a,i,n){async function r(i){n?a.G1.toRprLEM(t,e,i):a.G1.toRprUncompressed(t,e,i),e+=2*a.F1.n8}async function o(i){n?a.G2.toRprLEM(t,e,i):a.G2.toRprUncompressed(t,e,i),e+=2*a.F2.n8}return r(i.tau.g1_s),r(i.tau.g1_sx),r(i.alpha.g1_s),r(i.alpha.g1_sx),r(i.beta.g1_s),r(i.beta.g1_sx),o(i.tau.g2_spx),o(i.alpha.g2_spx),o(i.beta.g2_spx),t}async function tB(t,e,a,i){let n=new Uint8Array(12*e.F1.n8+6*e.F2.n8);tG(n,0,e,a,i),await t.write(n)}async function t_(t,e){let a={};a.tauG1=await s(),a.tauG2=await u(),a.alphaG1=await s(),a.betaG1=await s(),a.betaG2=await u(),a.key=await tF(t,e,!0),a.partialHash=await t.read(216),a.nextChallenge=await t.read(64),a.type=await t.readULE32();let i=new Uint8Array(12*e.G1.F.n8+6*e.G2.F.n8);tG(i,0,e,a.key,!1);let n=h.default(64);n.setPartialHash(a.partialHash),n.update(i),a.responseHash=n.digest();let r=await t.readULE32(),o=t.pos,l=0;for(;t.pos-o<r;){let t=await d(1);if(t[0]<=l)throw Error("Parameters in the contribution must be sorted");if(l=t[0],1==t[0]){let t=await d(1),e=await d(t[0]);a.name=new TextDecoder().decode(e)}else if(2==t[0]){let t=await d(1);a.numIterationsExp=t[0]}else if(3==t[0]){let t=await d(1);a.beaconHash=await d(t[0])}else throw Error("Parameter not recognized")}if(t.pos!=o+r)throw Error("Parametes do not match");return a;async function s(){let a=await t.read(2*e.G1.F.n8);return e.G1.fromRprLEM(a)}async function u(){let a=await t.read(2*e.G2.F.n8);return e.G2.fromRprLEM(a)}async function d(e){let a=await t.read(e);return new Uint8Array(a)}}async function tT(t,e,a){if(!a[7])throw Error(t.fileName+": File has no  contributions");if(a[7][0].length>1)throw Error(t.fileName+": File has more than one contributions section");t.pos=a[7][0].p;let i=await t.readULE32(),n=[];for(let a=0;a<i;a++){let i=await t_(t,e);i.id=a+1,n.push(i)}if(t.pos-a[7][0].p!=a[7][0].size)throw Error("Invalid contribution section size");return n}async function tL(t,e,a){let i=new Uint8Array(2*e.F1.n8),n=new Uint8Array(2*e.F2.n8);await o(a.tauG1),await l(a.tauG2),await o(a.alphaG1),await o(a.betaG1),await l(a.betaG2),await tB(t,e,a.key,!0),await t.write(a.partialHash),await t.write(a.nextChallenge),await t.writeULE32(a.type||0);let r=[];if(a.name){r.push(1);let t=new TextEncoder("utf-8").encode(a.name.substring(0,64));r.push(t.byteLength);for(let e=0;e<t.byteLength;e++)r.push(t[e])}if(1==a.type){r.push(2),r.push(a.numIterationsExp),r.push(3),r.push(a.beaconHash.byteLength);for(let t=0;t<a.beaconHash.byteLength;t++)r.push(a.beaconHash[t])}if(r.length>0){let e=new Uint8Array(r);await t.writeULE32(e.byteLength),await t.write(e)}else await t.writeULE32(0);async function o(a){e.G1.toRprLEM(i,0,a),await t.write(i)}async function l(a){e.G2.toRprLEM(n,0,a),await t.write(n)}}async function tA(t,e,a){await t.writeULE32(7);let i=t.pos;await t.writeULE64(0),await t.writeULE32(a.length);for(let i=0;i<a.length;i++)await tL(t,e,a[i]);let n=t.pos-i-8,r=t.pos;await t.writeULE64(n,i),t.pos=r}function tz(t,e,a){let i;a&&a.debug("Calculating First Challenge Hash");let n=new h.default(64),r=new Uint8Array(2*t.G1.F.n8),o=new Uint8Array(2*t.G2.F.n8);return t.G1.toRprUncompressed(r,0,t.G1.g),t.G2.toRprUncompressed(o,0,t.G2.g),n.update(h.default(64).digest()),i=2**e*2-1,a&&a.debug("Calculate Initial Hash: tauG1"),l(r,i),i=2**e,a&&a.debug("Calculate Initial Hash: tauG2"),l(o,i),a&&a.debug("Calculate Initial Hash: alphaTauG1"),l(r,i),a&&a.debug("Calculate Initial Hash: betaTauG1"),l(r,i),n.update(o),n.digest();function l(t,e){let i=Math.floor(e/341e3),r=e%341e3,o=new Uint8Array(341e3*t.byteLength);for(let e=0;e<341e3;e++)o.set(t,e*t.byteLength);for(let t=0;t<i;t++)n.update(o),a&&a.debug("Initial hash: "+341e3*t);for(let e=0;e<r;e++)n.update(t)}}async function tP(t,e,a,i){let n=await U(a,i),r=tv(t,e,n);return r}async function tR(t,e,a,i){if(1==e.type){let n=await tP(t,a.nextChallenge,e.beaconHash,e.numIterationsExp);if(!t.G1.eq(e.key.tau.g1_s,n.tau.g1_s))return i&&i.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.tau.g1_sx,n.tau.g1_sx))return i&&i.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G2.eq(e.key.tau.g2_spx,n.tau.g2_spx))return i&&i.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.alpha.g1_s,n.alpha.g1_s))return i&&i.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.alpha.g1_sx,n.alpha.g1_sx))return i&&i.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G2.eq(e.key.alpha.g2_spx,n.alpha.g2_spx))return i&&i.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.beta.g1_s,n.beta.g1_s))return i&&i.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.beta.g1_sx,n.beta.g1_sx))return i&&i.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G2.eq(e.key.beta.g2_spx,n.beta.g2_spx))return i&&i.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1}return(e.key.tau.g2_sp=t.G2.toAffine(ty(t,0,a.nextChallenge,e.key.tau.g1_s,e.key.tau.g1_sx)),e.key.alpha.g2_sp=t.G2.toAffine(ty(t,1,a.nextChallenge,e.key.alpha.g1_s,e.key.alpha.g1_sx)),e.key.beta.g2_sp=t.G2.toAffine(ty(t,2,a.nextChallenge,e.key.beta.g1_s,e.key.beta.g1_sx)),!0!==await L(t,e.key.tau.g1_s,e.key.tau.g1_sx,e.key.tau.g2_sp,e.key.tau.g2_spx))?(i&&i.error("INVALID key (tau) in challenge #"+e.id),!1):!0!==await L(t,e.key.alpha.g1_s,e.key.alpha.g1_sx,e.key.alpha.g2_sp,e.key.alpha.g2_spx)?(i&&i.error("INVALID key (alpha) in challenge #"+e.id),!1):!0!==await L(t,e.key.beta.g1_s,e.key.beta.g1_sx,e.key.beta.g2_sp,e.key.beta.g2_spx)?(i&&i.error("INVALID key (beta) in challenge #"+e.id),!1):!0!==await L(t,a.tauG1,e.tauG1,e.key.tau.g2_sp,e.key.tau.g2_spx)?(i&&i.error("INVALID tau*G1. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await L(t,e.key.tau.g1_s,e.key.tau.g1_sx,a.tauG2,e.tauG2)?(i&&i.error("INVALID tau*G2. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await L(t,a.alphaG1,e.alphaG1,e.key.alpha.g2_sp,e.key.alpha.g2_spx)?(i&&i.error("INVALID alpha*G1. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await L(t,a.betaG1,e.betaG1,e.key.beta.g2_sp,e.key.beta.g2_spx)?(i&&i.error("INVALID beta*G1. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await L(t,e.key.beta.g1_s,e.key.beta.g1_sx,a.betaG2,e.betaG2)?(i&&i.error("INVALID beta*G2. challenge #"+e.id+"It does not follow the previous contribution"),!1):(i&&i.info("Powers Of tau file OK!"),!0)}async function tU(t,e,a,i,n,r,o,l,s,u){let d=n[r],f=2*d.F.n8,c=e[i][0].size/f;await g.startReadUniqueSection(t,e,i),await g.startWriteSection(a,i);let w=o;for(let e=0;e<c;e+=65536){let i;u&&u.debug(`Applying key: ${s}: ${e}/${c}`);let r=Math.min(c-e,65536);i=await t.read(r*f),i=await d.batchApplyKey(i,w,l),await a.write(i),w=n.Fr.mul(w,n.Fr.exp(l,r))}await g.endWriteSection(a),await g.endReadSection(t)}async function t$(t,e,a,i,n,r,o,l,s,u,d){let f=i[n],c=2*f.F.n8,w=Math.floor(1048576/c),g=o;for(let n=0;n<r;n+=w){let o;d&&d.debug(`Applying key ${u}: ${n}/${r}`);let h=Math.min(r-n,w),m=await t.read(h*c),b=await f.batchUtoLEM(m),p=await f.batchApplyKey(b,g,l);o="COMPRESSED"==s?await f.batchLEMtoC(p):await f.batchLEMtoU(p),a&&a.update(o),await e.write(o),g=i.Fr.mul(g,i.Fr.exp(l,h))}}var tk=Object.freeze({__proto__:null,newAccumulator:async function(t,e,a,i){await h.default.ready();let n=await g.createBinFile(a,"ptau",1,7);await tx(n,t,e,0);let r=t.G1.oneAffine,o=t.G2.oneAffine;await g.startWriteSection(n,2);let l=2**e*2-1;for(let t=0;t<l;t++)await n.write(r),i&&t%1e5==0&&t&&i.log("tauG1: "+t);await g.endWriteSection(n),await g.startWriteSection(n,3);let s=2**e;for(let t=0;t<s;t++)await n.write(o),i&&t%1e5==0&&t&&i.log("tauG2: "+t);await g.endWriteSection(n),await g.startWriteSection(n,4);let u=2**e;for(let t=0;t<u;t++)await n.write(r),i&&t%1e5==0&&t&&i.log("alphaTauG1: "+t);await g.endWriteSection(n),await g.startWriteSection(n,5);let d=2**e;for(let t=0;t<d;t++)await n.write(r),i&&t%1e5==0&&t&&i.log("betaTauG1: "+t);await g.endWriteSection(n),await g.startWriteSection(n,6),await n.write(o),await g.endWriteSection(n),await g.startWriteSection(n,7),await n.writeULE32(0),await g.endWriteSection(n),await n.close();let f=tz(t,e,i);return i&&i.debug(_(h.default(64).digest(),"Blank Contribution Hash:")),i&&i.info(_(f,"First Contribution Hash:")),f},exportChallenge:async function(t,e,a){let i,n;await h.default.ready();let{fd:r,sections:o}=await g.readBinFile(t,"ptau",1),{curve:l,power:s}=await tC(r,o),u=await tT(r,l,o);0==u.length?(i=h.default(64).digest(),n=tz(l,s)):(i=u[u.length-1].responseHash,n=u[u.length-1].nextChallenge),a&&a.info(_(i,"Last Response Hash: ")),a&&a.info(_(n,"New Challenge Hash: "));let d=await b.createOverride(e),f=h.default(64);await d.write(i),f.update(i),await w(2,"G1",2**s*2-1,"tauG1"),await w(3,"G2",2**s,"tauG2"),await w(4,"G1",2**s,"alphaTauG1"),await w(5,"G1",2**s,"betaTauG1"),await w(6,"G2",1,"betaG2"),await r.close(),await d.close();let c=f.digest();if(!T(n,c))throw a&&a.info(_(c,"Calc Curret Challenge Hash: ")),a&&a.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return n;async function w(t,e,i,n){let s=l[e],u=2*s.F.n8,c=Math.floor(16777216/u);await g.startReadUniqueSection(r,o,t);for(let t=0;t<i;t+=c){let e;a&&a.debug(`Exporting ${n}: ${t}/${i}`);let o=Math.min(i-t,c);e=await r.read(o*u),e=await s.batchLEMtoU(e),await d.write(e),f.update(e)}await g.endReadSection(r)}},importResponse:async function(t,e,a,i,n,r){let o,l;await h.default.ready();let s=new Uint8Array(64);for(let t=0;t<64;t++)s[t]=255;let{fd:u,sections:d}=await g.readBinFile(t,"ptau",1),{curve:f,power:c}=await tC(u,d),w=await tT(u,f,d),m={};i&&(m.name=i);let p=2*f.F1.n8,y=f.F1.n8,S=2*f.F2.n8,v=f.F2.n8,x=await b.readExisting(e);if(x.totalSize!=64+(2**c*2-1)*y+2**c*v+2**c*y+2**c*y+v+6*p+3*S)throw Error("Size of the contribution is invalid");o=w.length>0?w[w.length-1].nextChallenge:tz(f,c,r);let C=await g.createBinFile(a,"ptau",1,n?7:2);await tx(C,f,c);let F=await x.read(64);if(T(s,o)&&(o=F,w[w.length-1].nextChallenge=o),!T(F,o))throw Error("Wrong contribution. this contribution is not based on the previus hash");let E=new h.default(64);E.update(F);let G=[];l=await A(x,C,"G1",2,2**c*2-1,[1],"tauG1"),m.tauG1=l[0],l=await A(x,C,"G2",3,2**c,[1],"tauG2"),m.tauG2=l[0],l=await A(x,C,"G1",4,2**c,[0],"alphaG1"),m.alphaG1=l[0],l=await A(x,C,"G1",5,2**c,[0],"betaG1"),m.betaG1=l[0],l=await A(x,C,"G2",6,1,[0],"betaG2"),m.betaG2=l[0],m.partialHash=E.getPartialHash();let B=await x.read(12*f.F1.n8+6*f.F2.n8);m.key=tE(B,0,f,!1),E.update(new Uint8Array(B));let L=E.digest();if(r&&r.info(_(L,"Contribution Response Hash imported: ")),n){let t=new h.default(64);t.update(L),await R(t,C,"G1",2,2**c*2-1,"tauG1",r),await R(t,C,"G2",3,2**c,"tauG2",r),await R(t,C,"G1",4,2**c,"alphaTauG1",r),await R(t,C,"G1",5,2**c,"betaTauG1",r),await R(t,C,"G2",6,1,"betaG2",r),m.nextChallenge=t.digest(),r&&r.info(_(m.nextChallenge,"Next Challenge Hash: "))}else m.nextChallenge=s;return w.push(m),await tA(C,f,w),await x.close(),await C.close(),await u.close(),m.nextChallenge;async function A(t,e,a,i,r,o,l){return n?await z(t,e,a,i,r,o,l):await P(t,e,a,i,r,o,l)}async function z(t,e,a,i,n,o,l){let s=f[a],u=s.F.n8,d=2*s.F.n8,c=[];await g.startWriteSection(e,i);let w=Math.floor(16777216/d);G[i]=e.pos;for(let a=0;a<n;a+=w){r&&r.debug(`Importing ${l}: ${a}/${n}`);let i=Math.min(n-a,w),f=await t.read(i*u);E.update(f);let g=await s.batchCtoLEM(f);await e.write(g);for(let t=0;t<o.length;t++){let e=o[t];if(e>=a&&e<a+i){let t=s.fromRprLEM(g,(e-a)*d);c.push(t)}}}return await g.endWriteSection(e),c}async function P(t,e,a,i,n,o,l){let s=f[a],u=s.F.n8,d=[],c=Math.floor(16777216/u);for(let e=0;e<n;e+=c){r&&r.debug(`Importing ${l}: ${e}/${n}`);let a=Math.min(n-e,c),i=await t.read(a*u);E.update(i);for(let t=0;t<o.length;t++){let n=o[t];if(n>=e&&n<e+a){let t=s.fromRprCompressed(i,(n-e)*u);d.push(t)}}}return d}async function R(t,e,a,i,n,r,o){let l=f[a],s=2*l.F.n8,u=Math.floor(16777216/s),d=e.pos;e.pos=G[i];for(let a=0;a<n;a+=u){o&&o.debug(`Hashing ${r}: ${a}/${n}`);let i=Math.min(n-a,u),d=await e.read(i*s),f=await l.batchLEMtoU(d);t.update(f)}e.pos=d}},verify:async function(t,e){let a;await h.default.ready();let{fd:i,sections:r}=await g.readBinFile(t,"ptau",1),{curve:o,power:l,ceremonyPower:s}=await tC(i,r),u=await tT(i,o,r);e&&e.debug("power: 2**"+l),e&&e.debug("Computing initial contribution hash");let d={tauG1:o.G1.g,tauG2:o.G2.g,alphaG1:o.G1.g,betaG1:o.G1.g,betaG2:o.G2.g,nextChallenge:tz(o,s,e),responseHash:h.default(64).digest()};if(0==u.length)return e&&e.error("This file has no contribution! It cannot be used in production"),!1;a=u.length>1?u[u.length-2]:d;let f=u[u.length-1];e&&e.debug("Validating contribution #"+u[u.length-1].id);let c=await tR(o,f,a,e);if(!c)return!1;let w=h.default(64);w.update(f.responseHash),e&&e.debug("Verifying powers in tau*G1 section");let m=await F(2,"G1","tauG1",2**l*2-1,[0,1],e);if(!0!==await L(o,m.R1,m.R2,o.G2.g,f.tauG2))return e&&e.error("tauG1 section. Powers do not match"),!1;if(!o.G1.eq(o.G1.g,m.singularPoints[0]))return e&&e.error("First element of tau*G1 section must be the generator"),!1;if(!o.G1.eq(f.tauG1,m.singularPoints[1]))return e&&e.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;e&&e.debug("Verifying powers in tau*G2 section");let b=await F(3,"G2","tauG2",2**l,[0,1],e);if(!0!==await L(o,o.G1.g,f.tauG1,b.R1,b.R2))return e&&e.error("tauG2 section. Powers do not match"),!1;if(!o.G2.eq(o.G2.g,b.singularPoints[0]))return e&&e.error("First element of tau*G2 section must be the generator"),!1;if(!o.G2.eq(f.tauG2,b.singularPoints[1]))return e&&e.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;e&&e.debug("Verifying powers in alpha*tau*G1 section");let p=await F(4,"G1","alphatauG1",2**l,[0],e);if(!0!==await L(o,p.R1,p.R2,o.G2.g,f.tauG2))return e&&e.error("alphaTauG1 section. Powers do not match"),!1;if(!o.G1.eq(f.alphaG1,p.singularPoints[0]))return e&&e.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;e&&e.debug("Verifying powers in beta*tau*G1 section");let y=await F(5,"G1","betatauG1",2**l,[0],e);if(!0!==await L(o,y.R1,y.R2,o.G2.g,f.tauG2))return e&&e.error("betaTauG1 section. Powers do not match"),!1;if(!o.G1.eq(f.betaG1,y.singularPoints[0]))return e&&e.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;let S=await C(e);if(!o.G2.eq(f.betaG2,S))return e&&e.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;let v=w.digest();if(l==s&&!T(v,f.nextChallenge))return e&&e.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;e&&e.info(_(v,"Next challenge hash: ")),x(f,a);for(let t=u.length-2;t>=0;t--){let a=u[t],i=t>0?u[t-1]:d,n=await tR(o,a,i,e);if(!n)return!1;x(a,i)}if(e&&e.info("-----------------------------------------------------"),r[12]&&r[13]&&r[14]&&r[15]){if(!await E("G1",2,12,"tauG1",e)||!await E("G2",3,13,"tauG2",e)||!await E("G1",4,14,"alphaTauG1",e)||!await E("G1",5,15,"betaTauG1",e))return!1}else e&&e.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await i.close(),e&&e.info("Powers of Tau Ok!"),!0;function x(t,a){if(!e)return;e.info("-----------------------------------------------------"),e.info(`Contribution #${t.id}: ${t.name||""}`),e.info(_(t.nextChallenge,"Next Challenge: "));let i=new Uint8Array(12*o.G1.F.n8+6*o.G2.F.n8);tG(i,0,o,t.key,!1);let n=h.default(64);n.setPartialHash(t.partialHash),n.update(i);let r=n.digest();e.info(_(r,"Response Hash:")),e.info(_(a.nextChallenge,"Response Hash:")),1==t.type&&(e.info(`Beacon generator: ${k(t.beaconHash)}`),e.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}async function C(t){let e=o.G2,a=2*e.F.n8,n=new Uint8Array(a);if(!r[6])throw t.error("File has no BetaG2 section"),Error("File has no BetaG2 section");if(r[6].length>1)throw t.error("File has no BetaG2 section"),Error("File has more than one GetaG2 section");i.pos=r[6][0].p;let l=await i.read(a),s=e.fromRprLEM(l);return e.toRprUncompressed(n,0,s),w.update(n),s}async function F(t,e,a,n,l,s){let u=o[e],d=2*u.F.n8;await g.startReadUniqueSection(i,r,t);let f=[],c=u.zero,h=u.zero,m=u.zero;for(let t=0;t<n;t+=65536){s&&s.debug(`points relations: ${a}: ${t}/${n} `);let e=Math.min(n-t,65536),r=await i.read(e*d),o=await u.batchLEMtoU(r);w.update(o);let g=A(4*(e-1));if(t>0){let t=u.fromRprLEM(r,0),e=P(A(4),0);c=u.add(c,u.timesScalar(m,e)),h=u.add(h,u.timesScalar(t,e))}let b=await u.multiExpAffine(r.slice(0,(e-1)*d),g),p=await u.multiExpAffine(r.slice(d),g);c=u.add(c,b),h=u.add(h,p),m=u.fromRprLEM(r,(e-1)*d);for(let a=0;a<l.length;a++){let i=l[a];if(i>=t&&i<t+e){let e=u.fromRprLEM(r,(i-t)*d);f.push(e)}}}return await g.endReadSection(i),{R1:c,R2:h,singularPoints:f}}async function E(t,e,a,s,u){u&&u.debug(`Verifying phase2 calculated values ${s}...`);let d=o[t],f=2*d.F.n8,c=Array(8);for(let t=0;t<8;t++)c[t]=P(A(4),0);for(let t=0;t<=l;t++){let e=await w(t);if(!e)return!1}if(2==e){let t=await w(l+1);if(!t)return!1}return!0;async function w(t){let w;u&&u.debug(`Power ${t}...`);let h=o.Fr.n8,m=2**t,b=new Uint32Array(m),p=new n.ChaCha(c);u&&u.debug(`Creating random numbers Powers${t}...`);for(let e=0;e<m;e++)t==l+1&&e==m-1?b[e]=0:b[e]=p.nextU32();b=new Uint8Array(b.buffer,b.byteOffset,b.byteLength),u&&u.debug(`reading points Powers${t}...`),await g.startReadUniqueSection(i,r,e),w=new n.BigBuffer(m*f),t==l+1?(await i.readToBuffer(w,0,(m-1)*f),w.set(o.G1.zeroAffine,(m-1)*f)):await i.readToBuffer(w,0,m*f),await g.endReadSection(i,!0);let y=await d.multiExpAffine(w,b,u,s+"_"+t);b=new n.BigBuffer(m*h),p=new n.ChaCha(c);let S=new Uint8Array(4),v=new DataView(S.buffer);u&&u.debug(`Creating random numbers Powers${t}...`);for(let e=0;e<m;e++)(e!=m-1||t!=l+1)&&(v.setUint32(0,p.nextU32(),!0),b.set(S,e*h));u&&u.debug(`batchToMontgomery ${t}...`),b=await o.Fr.batchToMontgomery(b),u&&u.debug(`fft ${t}...`),b=await o.Fr.fft(b),u&&u.debug(`batchFromMontgomery ${t}...`),b=await o.Fr.batchFromMontgomery(b),u&&u.debug(`reading points Lagrange${t}...`),await g.startReadUniqueSection(i,r,a),i.pos+=f*(2**t-1),await i.readToBuffer(w,0,m*f),await g.endReadSection(i,!0);let x=await d.multiExpAffine(w,b,u,s+"_"+t+"_transformed");return!!d.eq(y,x)||(u&&u.error("Phase2 caclutation does not match with powers of tau"),!1)}}},challengeContribute:async function(t,e,a,i,n){await h.default.ready();let r=await b.readExisting(e),o=16*t.F1.n64,l=16*t.F2.n64,s=(r.totalSize+o-64-l)/(4*o+l),u=s,d=0;for(;u>1;)u/=2,d+=1;if(2**d!=s)throw Error("Invalid file size");n&&n.debug("Power to tau size: "+d);let f=await R(i),c=await b.createOverride(a),w=h.default(64);for(let t=0;t<r.totalSize;t+=r.pageSize){n&&n.debug(`Hashing challenge ${t}/${r.totalSize}`);let e=Math.min(r.totalSize-t,r.pageSize),a=await r.read(e);w.update(a)}let g=await r.read(64,0);n&&n.info(_(g,"Claimed Previous Response Hash: "));let m=w.digest();n&&n.info(_(m,"Current Challenge Hash: "));let p=tv(t,m,f);n&&["tau","alpha","beta"].forEach(e=>{n.debug(e+".g1_s: "+t.G1.toString(p[e].g1_s,16)),n.debug(e+".g1_sx: "+t.G1.toString(p[e].g1_sx,16)),n.debug(e+".g2_sp: "+t.G2.toString(p[e].g2_sp,16)),n.debug(e+".g2_spx: "+t.G2.toString(p[e].g2_spx,16)),n.debug("")});let y=h.default(64);await c.write(m),y.update(m),await t$(r,c,y,t,"G1",2**d*2-1,t.Fr.one,p.tau.prvKey,"COMPRESSED","tauG1",n),await t$(r,c,y,t,"G2",2**d,t.Fr.one,p.tau.prvKey,"COMPRESSED","tauG2",n),await t$(r,c,y,t,"G1",2**d,p.alpha.prvKey,p.tau.prvKey,"COMPRESSED","alphaTauG1",n),await t$(r,c,y,t,"G1",2**d,p.beta.prvKey,p.tau.prvKey,"COMPRESSED","betaTauG1",n),await t$(r,c,y,t,"G2",1,p.beta.prvKey,p.tau.prvKey,"COMPRESSED","betaTauG2",n);let S=new Uint8Array(12*t.F1.n8+6*t.F2.n8);tG(S,0,t,p,!1),await c.write(S),y.update(S);let v=y.digest();n&&n.info(_(v,"Contribution Response Hash: ")),await c.close(),await r.close()},beacon:async function(t,e,a,i,n,r){let o,l;let s=$(i);if(0==s.byteLength||2*s.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(s.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await h.default.ready();let{fd:u,sections:d}=await g.readBinFile(t,"ptau",1),{curve:f,power:c,ceremonyPower:w}=await tC(u,d);if(c!=w)return r&&r.error("This file has been reduced. You cannot contribute into a reduced file."),!1;d[12]&&r&&r.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let m=await tT(u,f,d),b={name:a,type:1,numIterationsExp:n,beaconHash:s};o=m.length>0?m[m.length-1].nextChallenge:tz(f,c,r),b.key=await tP(f,o,s,n);let p=new h.default(64);p.update(o);let y=await g.createBinFile(e,"ptau",1,7);await tx(y,f,c);let S=[];l=await F(2,"G1",2**c*2-1,f.Fr.e(1),b.key.tau.prvKey,"tauG1",r),b.tauG1=l[1],l=await F(3,"G2",2**c,f.Fr.e(1),b.key.tau.prvKey,"tauG2",r),b.tauG2=l[1],l=await F(4,"G1",2**c,b.key.alpha.prvKey,b.key.tau.prvKey,"alphaTauG1",r),b.alphaG1=l[0],l=await F(5,"G1",2**c,b.key.beta.prvKey,b.key.tau.prvKey,"betaTauG1",r),b.betaG1=l[0],l=await F(6,"G2",1,b.key.beta.prvKey,b.key.tau.prvKey,"betaTauG2",r),b.betaG2=l[0],b.partialHash=p.getPartialHash();let v=new Uint8Array(12*f.F1.n8+6*f.F2.n8);tG(v,0,f,b.key,!1),p.update(new Uint8Array(v));let x=p.digest();r&&r.info(_(x,"Contribution Response Hash imported: "));let C=new h.default(64);return C.update(x),await E(y,"G1",2,2**c*2-1,"tauG1",r),await E(y,"G2",3,2**c,"tauG2",r),await E(y,"G1",4,2**c,"alphaTauG1",r),await E(y,"G1",5,2**c,"betaTauG1",r),await E(y,"G2",6,1,"betaG2",r),b.nextChallenge=C.digest(),r&&r.info(_(b.nextChallenge,"Next Challenge Hash: ")),m.push(b),await tA(y,f,m),await u.close(),await y.close(),x;async function F(t,e,a,i,n,r,o){let l=[];u.pos=d[t][0].p,await g.startWriteSection(y,t),S[t]=y.pos;let s=f[e],c=2*s.F.n8,w=Math.floor(1048576/c),h=i;for(let t=0;t<a;t+=w){o&&o.debug(`applying key${r}: ${t}/${a}`);let e=Math.min(a-t,w),i=await u.read(e*c),d=await s.batchApplyKey(i,h,n),g=y.write(d),m=await s.batchLEMtoC(d);if(p.update(m),await g,0==t)for(let t=0;t<Math.min(2,a);t++)l.push(s.fromRprLEM(d,t*c));h=f.Fr.mul(h,f.Fr.exp(n,e))}return await g.endWriteSection(y),l}async function E(t,e,a,i,n,r){let o=f[e],l=2*o.F.n8,s=Math.floor(16777216/l),u=t.pos;t.pos=S[a];for(let e=0;e<i;e+=s){r&&r.debug(`Hashing ${n}: ${e}/${i}`);let a=Math.min(i-e,s),u=await t.read(a*l),d=await o.batchLEMtoU(u);C.update(d)}t.pos=u}},contribute:async function(t,e,a,i,n){let r,o;await h.default.ready();let{fd:l,sections:s}=await g.readBinFile(t,"ptau",1),{curve:u,power:d,ceremonyPower:f}=await tC(l,s);if(d!=f)throw n&&n.error("This file has been reduced. You cannot contribute into a reduced file."),Error("This file has been reduced. You cannot contribute into a reduced file.");s[12]&&n&&n.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let c=await tT(l,u,s),w={name:a,type:0},m=await R(i);r=c.length>0?c[c.length-1].nextChallenge:tz(u,d,n),w.key=tv(u,r,m);let b=new h.default(64);b.update(r);let p=await g.createBinFile(e,"ptau",1,7);await tx(p,u,d);let y=[];o=await C(2,"G1",2**d*2-1,u.Fr.e(1),w.key.tau.prvKey,"tauG1"),w.tauG1=o[1],o=await C(3,"G2",2**d,u.Fr.e(1),w.key.tau.prvKey,"tauG2"),w.tauG2=o[1],o=await C(4,"G1",2**d,w.key.alpha.prvKey,w.key.tau.prvKey,"alphaTauG1"),w.alphaG1=o[0],o=await C(5,"G1",2**d,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG1"),w.betaG1=o[0],o=await C(6,"G2",1,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG2"),w.betaG2=o[0],w.partialHash=b.getPartialHash();let S=new Uint8Array(12*u.F1.n8+6*u.F2.n8);tG(S,0,u,w.key,!1),b.update(new Uint8Array(S));let v=b.digest();n&&n.info(_(v,"Contribution Response Hash imported: "));let x=new h.default(64);return x.update(v),await F(p,"G1",2,2**d*2-1,"tauG1"),await F(p,"G2",3,2**d,"tauG2"),await F(p,"G1",4,2**d,"alphaTauG1"),await F(p,"G1",5,2**d,"betaTauG1"),await F(p,"G2",6,1,"betaG2"),w.nextChallenge=x.digest(),n&&n.info(_(w.nextChallenge,"Next Challenge Hash: ")),c.push(w),await tA(p,u,c),await l.close(),await p.close(),v;async function C(t,e,a,i,r,o){let d=[];l.pos=s[t][0].p,await g.startWriteSection(p,t),y[t]=p.pos;let f=u[e],c=2*f.F.n8,w=Math.floor(1048576/c),h=i;for(let t=0;t<a;t+=w){n&&n.debug(`processing: ${o}: ${t}/${a}`);let e=Math.min(a-t,w),i=await l.read(e*c),s=await f.batchApplyKey(i,h,r),g=p.write(s),m=await f.batchLEMtoC(s);if(b.update(m),await g,0==t)for(let t=0;t<Math.min(2,a);t++)d.push(f.fromRprLEM(s,t*c));h=u.Fr.mul(h,u.Fr.exp(r,e))}return await g.endWriteSection(p),d}async function F(t,e,a,i,r){let o=u[e],l=2*o.F.n8,s=Math.floor(16777216/l),d=t.pos;t.pos=y[a];for(let e=0;e<i;e+=s){n&&e&&n.debug(`Hashing ${r}: `+e);let a=Math.min(i-e,s),u=await t.read(a*l),d=await o.batchLEMtoU(u);x.update(d)}t.pos=d}},preparePhase2:async function(t,e,a){let{fd:i,sections:r}=await g.readBinFile(t,"ptau",1),{curve:o,power:l}=await tC(i,r),s=await g.createBinFile(e,"ptau",1,11);async function u(t,e,u,d){a&&a.debug("Starting section: "+d),await g.startWriteSection(s,e);for(let t=0;t<=l;t++)await f(t);async function f(e){let f;let c=2**e,w=o[u];o.Fr;let h=2*w.F.n8;w.F.n8,f=new n.BigBuffer(c*h),await g.startReadUniqueSection(i,r,t),2==t&&e==l+1?(await i.readToBuffer(f,0,(c-1)*h),f.set(o.G1.zeroAffine,(c-1)*h)):await i.readToBuffer(f,0,c*h),await g.endReadSection(i,!0),f=await w.lagrangeEvaluations(f,"affine","affine",a,d),await s.write(f)}2==t&&await f(l+1),await g.endWriteSection(s)}await tx(s,o,l),await g.copySection(i,r,s,2),await g.copySection(i,r,s,3),await g.copySection(i,r,s,4),await g.copySection(i,r,s,5),await g.copySection(i,r,s,6),await g.copySection(i,r,s,7),await u(2,12,"G1","tauG1"),await u(3,13,"G2","tauG2"),await u(4,14,"G1","alphaTauG1"),await u(5,15,"G1","betaTauG1"),await i.close(),await s.close()},truncate:async function(t,e,a){let{fd:i,sections:n}=await g.readBinFile(t,"ptau",1),{curve:r,power:o,ceremonyPower:l}=await tC(i,n),s=2*r.G1.F.n8,u=2*r.G2.F.n8;for(let t=1;t<o;t++)await d(t);return await i.close(),!0;async function d(t){let o=t.toString();for(;o.length<2;)o="0"+o;a&&a.debug("Writing Power: "+o);let d=await g.createBinFile(e+o+".ptau","ptau",1,11);await tx(d,r,t,l),await g.copySection(i,n,d,2,(2**t*2-1)*s),await g.copySection(i,n,d,3,2**t*u),await g.copySection(i,n,d,4,2**t*s),await g.copySection(i,n,d,5,2**t*s),await g.copySection(i,n,d,6,u),await g.copySection(i,n,d,7),await g.copySection(i,n,d,12,(2**(t+1)*2-1)*s),await g.copySection(i,n,d,13,(2**t*2-1)*u),await g.copySection(i,n,d,14,(2**t*2-1)*s),await g.copySection(i,n,d,15,(2**t*2-1)*s),await d.close()}},convert:async function(t,e,a){let{fd:i,sections:r}=await g.readBinFile(t,"ptau",1),{curve:o,power:l}=await tC(i,r),s=await g.createBinFile(e,"ptau",1,11);async function u(t,e,u,d){a&&a.debug("Starting section: "+d),await g.startWriteSection(s,e);let f=r[e][0].size,c=i.pageSize;await g.startReadUniqueSection(i,r,e);for(let t=0;t<f;t+=c){let e=Math.min(f-t,c),a=await i.read(e);await s.write(a)}async function w(e){let f;let c=2**e,w=o[u],h=2*w.F.n8;f=new n.BigBuffer(c*h),await g.startReadUniqueSection(i,r,t),2==t&&e==l+1?(await i.readToBuffer(f,0,(c-1)*h),f.set(o.G1.zeroAffine,(c-1)*h)):await i.readToBuffer(f,0,c*h),await g.endReadSection(i,!0),f=await w.lagrangeEvaluations(f,"affine","affine",a,d),await s.write(f)}await g.endReadSection(i),2==t&&await w(l+1),await g.endWriteSection(s)}await tx(s,o,l),await g.copySection(i,r,s,2),await g.copySection(i,r,s,3),await g.copySection(i,r,s,4),await g.copySection(i,r,s,5),await g.copySection(i,r,s,6),await g.copySection(i,r,s,7),await u(2,12,"G1","tauG1"),await g.copySection(i,r,s,13),await g.copySection(i,r,s,14),await g.copySection(i,r,s,15),await i.close(),await s.close()},exportJson:async function(t,e){let{fd:a,sections:i}=await g.readBinFile(t,"ptau",1),{curve:n,power:r}=await tC(a,i),o={};return o.q=n.q,o.power=r,o.contributions=await tT(a,n,i),o.tauG1=await l(2,"G1",2**r*2-1,"tauG1"),o.tauG2=await l(3,"G2",2**r,"tauG2"),o.alphaTauG1=await l(4,"G1",2**r,"alphaTauG1"),o.betaTauG1=await l(5,"G1",2**r,"betaTauG1"),o.betaG2=await l(6,"G2",1,"betaG2"),o.lTauG1=await s(12,"G1","lTauG1"),o.lTauG2=await s(13,"G2","lTauG2"),o.lAlphaTauG1=await s(14,"G1","lAlphaTauG2"),o.lBetaTauG1=await s(15,"G1","lBetaTauG2"),await a.close(),I(n.Fr,o);async function l(t,r,o,l){let s=n[r],u=2*s.F.n8,d=[];await g.startReadUniqueSection(a,i,t);for(let t=0;t<o;t++){e&&t&&t%1e4==0&&console.log(`${l}: `+t);let i=await a.read(u);d.push(s.fromRprLEM(i,0))}return await g.endReadSection(a),d}async function s(t,o,l){let s=n[o],u=2*s.F.n8,d=[];await g.startReadUniqueSection(a,i,t);for(let t=0;t<=r;t++){e&&console.log(`${l}: Power: ${t}`),d[t]=[];let i=2**t;for(let n=0;n<i;n++){e&&n&&n%1e4==0&&console.log(`${l}: ${n}/${i}`);let r=await a.read(u);d[t].push(s.fromRprLEM(r,0))}}return await g.endReadSection(a,!0),d}}});let tI=n.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),tO=n.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");var tq=Object.freeze({__proto__:null,print:function(t,e,a){for(let i=0;i<t.constraints.length;i++)!function(i){let n=a=>{let i="",n=Object.keys(a);return n.forEach(n=>{let r=e.varIdx2Name[n];"one"==r&&(r="1");let o=t.curve.Fr.toString(a[n]);"1"==o&&(o=""),"-1"==o&&(o="-"),""!=i&&"-"!=o[0]&&(o="+"+o),""!=i&&(o=" "+o),i=i+o+r}),i},r=`[ ${n(i[0])} ] * [ ${n(i[1])} ] - [ ${n(i[2])} ] = 0`;a&&a.info(r)}(t.constraints[i])},info:async function(t,e){let a=await u.readR1cs(t);return n.Scalar.eq(a.prime,tO)?e&&e.info("Curve: bn-128"):n.Scalar.eq(a.prime,tI)?e&&e.info("Curve: bls12-381"):e&&e.info(`Unknown Curve. Prime: ${n.Scalar.toString(a.prime)}`),e&&e.info(`# of Wires: ${a.nVars}`),e&&e.info(`# of Constraints: ${a.nConstraints}`),e&&e.info(`# of Private Inputs: ${a.nPrvInputs}`),e&&e.info(`# of Public Inputs: ${a.nPubInputs}`),e&&e.info(`# of Labels: ${a.nLabels}`),e&&e.info(`# of Outputs: ${a.nOutputs}`),a},exportJson:async function(t,e){let a=await u.readR1cs(t,!0,!0,!0,e),i=a.curve.Fr;return delete a.curve,delete a.F,I(i,a)}});async function tW(t){let e={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},a=await b.readExisting(t),i=await a.read(a.totalSize),n=new TextDecoder("utf-8").decode(i),r=n.split("\n");for(let t=0;t<r.length;t++){let a=r[t].split(",");4!=a.length||(e.varIdx2Name[a[1]]?e.varIdx2Name[a[1]]+="|"+a[3]:e.varIdx2Name[a[1]]=a[3],e.labelIdx2Name[a[0]]=a[3],e.componentIdx2Name[a[2]]||(e.componentIdx2Name[a[2]]=function(t){let e=t.split(".");return e.pop(),e.join(".")}(a[3])))}return await a.close(),e}let{unstringifyBigInts:tM}=n.utils;var tV=Object.freeze({__proto__:null,calculate:td,debug:async function(t,e,a,i,n,r){let o=tM(t),l=await b.readExisting(e),u=await l.read(l.totalSize);await l.close();let d={sanityCheck:!0},f=await tW(i);n.set&&(f||(f=await tW(i)),d.logSetSignal=function(t,e){r&&r.info("SET "+f.labelIdx2Name[t]+" <-- "+e.toString())}),n.get&&(f||(f=await tW(i)),d.logGetSignal=function(t,e){r&&r.info("GET "+f.labelIdx2Name[t]+" --> "+e.toString())}),n.trigger&&(f||(f=await tW(i)),d.logStartComponent=function(t){r&&r.info("START: "+f.componentIdx2Name[t])},d.logFinishComponent=function(t){r&&r.info("FINISH: "+f.componentIdx2Name[t])}),d.sym=f;let c=await s.WitnessCalculatorBuilder(u,d),w=await c.calculateWitness(o),h=await g.createBinFile(a,"wtns",2,2);await te(h,w,c.prime),await h.close()},exportJson:async function(t){let e=await tn(t);return e},check:async function(t,e,a){a&&a.info("WITNESS CHECKING STARTED"),a&&a.info("> Reading r1cs file");let{fd:i,sections:r}=await g.readBinFile(t,"r1cs",1,4194304,16777216),o=await u.readR1csFd(i,r,{loadConstraints:!1,loadCustomGates:!1});a&&a.info("> Reading witness file");let{fd:l,sections:s}=await g.readBinFile(e,"wtns",2,4194304,16777216),d=await ti(l,s);if(!n.Scalar.eq(o.prime,d.q))throw Error("Curve of the witness does not match the curve of the proving key");let f=await g.readSection(l,s,2);await l.close();let c=await F(o.prime),w=c.Fr,h=w.n8,m=await g.readSection(i,r,2);a&&(a.info("----------------------------"),a.info("  WITNESS CHECK"),a.info(`  Curve:          ${o.curve.name}`),a.info(`  Vars (wires):   ${o.nVars}`),a.info(`  Ouputs:         ${o.nOutputs}`),a.info(`  Public Inputs:  ${o.nPubInputs}`),a.info(`  Private Inputs: ${o.nPrvInputs}`),a.info(`  Labels:         ${o.nLabels}`),a.info(`  Constraints:    ${o.nConstraints}`),a.info(`  Custom Gates:   ${o.useCustomGates}`),a.info("----------------------------")),a&&a.info("> Checking witness correctness");let b=0,p=!0;for(let t=0;t<o.nConstraints;t++){a&&0!==t&&t%5e5==0&&a.info(`\xb7\xb7\xb7 processing r1cs constraints ${t}/${o.nConstraints}`);let e=S(),i=S(),n=S(),r=y(e),l=y(i),s=y(n);if(!w.eq(w.sub(w.mul(r,l),s),w.zero)){a.warn("\xb7\xb7\xb7 aborting checking process at constraint "+t),p=!1;break}}return i.close(),a&&(p?(a.info("WITNESS IS CORRECT"),a.info("WITNESS CHECKING FINISHED SUCCESSFULLY")):(a.warn("WITNESS IS NOT CORRECT"),a.warn("WITNESS CHECKING FINISHED UNSUCCESSFULLY"))),p;function y(t){let e=w.zero,a=Object.keys(t);return a.forEach(a=>{let i=w.fromRprLE(f.slice(a*h,a*h+h)),n=t[a];e=w.add(e,w.mul(i,n))}),e}function S(){let t={},e=m.slice(b,b+4);b+=4;let a=new DataView(e.buffer),i=a.getUint32(0,!0),n=m.slice(b,b+(4+o.n8)*i);b+=(4+o.n8)*i;let r=new DataView(n.buffer);for(let e=0;e<i;e++){let a=r.getUint32(e*(4+o.n8),!0),i=o.F.fromRprLE(n,e*(4+o.n8)+4);t[a]=i}return t}}});let tN={get:function(t,e){return isNaN(e)?t[e]:t.getElement(e)},set:function(t,e,a){return isNaN(e)?(t[e]=a,!0):t.setElement(e,a)}};class tQ{constructor(t){this.length=t||0,this.arr=Array(262144);for(let e=0;e<t;e+=262144)this.arr[e/262144]=Array(Math.min(262144,t-e));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,e){let a=Array(e-t);for(let i=t;i<e;i++)a[i-t]=this.getElement(i);return a}getElement(t){t=parseInt(t);let e=Math.floor(t/262144),a=t%262144;return this.arr[e]?this.arr[e][a]:void 0}setElement(t,e){t=parseInt(t);let a=Math.floor(t/262144);this.arr[a]||(this.arr[a]=Array(262144));let i=t%262144;return this.arr[a][i]=e,t>=this.length&&(this.length=t+1),!0}getKeys(){let t=new tj;for(let e=0;e<this.arr.length;e++)if(this.arr[e])for(let a=0;a<this.arr[e].length;a++)void 0!==this.arr[e][a]&&t.push(262144*e+a);return t}}class tj{constructor(t){let e=new tQ(t),a=new Proxy(e,tN);return a}}async function tH(t,e,a,r){let o,l,s;await h.default.ready();let d=h.default(64),{fd:f,sections:c}=await i.readBinFile(e,"ptau",1,4194304,16777216),{curve:w,power:g}=await tC(f,c),{fd:m,sections:b}=await i.readBinFile(t,"r1cs",1,4194304,16777216),p=await u.readR1csHeader(m,b,!1),y=await i.createBinFile(a,"zkey",1,10,4194304,16777216),S=2*w.G1.F.n8,v=2*w.G2.F.n8;if(p.prime!=w.r)return r&&r.error("r1cs curve does not match powers of tau ceremony curve"),-1;let x=B(p.nConstraints+p.nPubInputs+p.nOutputs+1-1)+1;if(x>g)return r&&r.error(`circuit too big for this power of tau ceremony. ${p.nConstraints}*2 > 2**${g}`),-1;if(!c[12])return r&&r.error("Powers of tau is not prepared."),-1;let C=p.nOutputs+p.nPubInputs,F=2**x;await i.startWriteSection(y,1),await y.writeULE32(1),await i.endWriteSection(y),await i.startWriteSection(y,2);let E=w.q,G=(Math.floor((n.Scalar.bitLength(E)-1)/64)+1)*8,T=w.r,L=(Math.floor((n.Scalar.bitLength(T)-1)/64)+1)*8,A=n.Scalar.mod(n.Scalar.shl(1,8*L),T),z=w.Fr.e(n.Scalar.mod(n.Scalar.mul(A,A),T));await y.writeULE32(G),await i.writeBigInt(y,E,G),await y.writeULE32(L),await i.writeBigInt(y,T,L),await y.writeULE32(p.nVars),await y.writeULE32(C),await y.writeULE32(F),o=await f.read(S,c[4][0].p),await y.write(o),o=await w.G1.batchLEMtoU(o),d.update(o),l=await f.read(S,c[5][0].p),await y.write(l),l=await w.G1.batchLEMtoU(l),d.update(l),s=await f.read(v,c[6][0].p),await y.write(s),s=await w.G2.batchLEMtoU(s),d.update(s);let P=new Uint8Array(S);w.G1.toRprLEM(P,0,w.G1.g);let R=new Uint8Array(v);w.G2.toRprLEM(R,0,w.G2.g);let U=new Uint8Array(S);w.G1.toRprUncompressed(U,0,w.G1.g);let $=new Uint8Array(v);w.G2.toRprUncompressed($,0,w.G2.g),await y.write(R),await y.write(P),await y.write(R),d.update($),d.update(U),d.update($),await i.endWriteSection(y),r&&r.info("Reading r1cs");let k=await i.readSection(m,b,2),I=new tj(p.nVars),O=new tj(p.nVars),q=new tj(p.nVars),W=new tj(p.nVars-C-1),M=Array(C+1);r&&r.info("Reading tauG1");let V=await i.readSection(f,c,12,(F-1)*S,F*S);r&&r.info("Reading tauG2");let N=await i.readSection(f,c,13,(F-1)*v,F*v);r&&r.info("Reading alphatauG1");let Q=await i.readSection(f,c,14,(F-1)*S,F*S);r&&r.info("Reading betatauG1");let j=await i.readSection(f,c,15,(F-1)*S,F*S);await D(),await K(3,"G1",M,"IC"),await Z(),await Y(),await K(8,"G1",W,"C"),await K(5,"G1",I,"A"),await K(6,"G1",O,"B1"),await K(7,"G2",q,"B2");let H=d.digest();return await i.startWriteSection(y,10),await y.write(H),await y.writeULE32(0),await i.endWriteSection(y),r&&r.info(_(H,"Circuit hash: ")),await y.close(),await m.close(),await f.close(),H;async function Z(){await i.startWriteSection(y,9);let t=new n.BigBuffer(F*S);if(x<w.Fr.s){let e=await i.readSection(f,c,12,(2*F-1)*S,2*F*S);for(let a=0;a<F;a++){r&&a%1e4==0&&r.debug(`spliting buffer: ${a}/${F}`);let i=e.slice((2*a+1)*S,(2*a+1)*S+S);t.set(i,a*S)}}else if(x==w.Fr.s){let e=c[12][0].p+(2**(x+1)-1)*S;await f.readToBuffer(t,0,F*S,e+F*S)}else throw r&&r.error("Circuit too big"),Error("Circuit too big for this curve");await y.write(t),await i.endWriteSection(y)}async function D(){let t=new Uint8Array(12+w.Fr.n8),e=new DataView(t.buffer),a=new Uint8Array(w.Fr.n8);w.Fr.toRprLE(a,0,w.Fr.e(1));let o=0;function l(){let t=k.slice(o,o+4);o+=4;let e=new DataView(t.buffer);return e.getUint32(0,!0)}let s=new tj;for(let t=0;t<p.nConstraints;t++){r&&t%1e4==0&&r.debug(`processing constraints: ${t}/${p.nConstraints}`);let e=l();for(let a=0;a<e;a++){let e=l(),a=o;o+=w.Fr.n8;let i=S*t,n=S*t;void 0===I[e]&&(I[e]=[]),I[e].push([0,i,a]),e<=C?(void 0===M[e]&&(M[e]=[]),M[e].push([3,n,a])):(void 0===W[e-C-1]&&(W[e-C-1]=[]),W[e-C-1].push([3,n,a])),s.push([0,t,e,a])}let a=l();for(let e=0;e<a;e++){let e=l(),a=o;o+=w.Fr.n8;let i=S*t,n=v*t,r=S*t;void 0===O[e]&&(O[e]=[]),O[e].push([0,i,a]),void 0===q[e]&&(q[e]=[]),q[e].push([1,n,a]),e<=C?(void 0===M[e]&&(M[e]=[]),M[e].push([2,r,a])):(void 0===W[e-C-1]&&(W[e-C-1]=[]),W[e-C-1].push([2,r,a])),s.push([1,t,e,a])}let i=l();for(let e=0;e<i;e++){let e=l(),a=o;o+=w.Fr.n8;let i=S*t;e<=C?(void 0===M[e]&&(M[e]=[]),M[e].push([0,i,a])):(void 0===W[e-C-1]&&(W[e-C-1]=[]),W[e-C-1].push([0,i,a]))}}for(let t=0;t<=C;t++){let e=S*(p.nConstraints+t),a=S*(p.nConstraints+t);void 0===I[t]&&(I[t]=[]),I[t].push([0,e,-1]),void 0===M[t]&&(M[t]=[]),M[t].push([3,a,-1]),s.push([0,p.nConstraints+t,t,-1])}await i.startWriteSection(y,4);let u=new n.BigBuffer(s.length*(12+w.Fr.n8)+4),d=new Uint8Array(4),f=new DataView(d.buffer);f.setUint32(0,s.length,!0),u.set(d);let c=4;for(let i=0;i<s.length;i++)r&&i%1e5==0&&r.debug(`writing coeffs: ${i}/${s.length}`),function(i){let n;e.setUint32(0,i[0],!0),e.setUint32(4,i[1],!0),e.setUint32(8,i[2],!0),n=i[3]>=0?w.Fr.fromRprLE(k.slice(i[3],i[3]+w.Fr.n8),0):w.Fr.fromRprLE(a,0);let r=w.Fr.mul(n,z);w.Fr.toRprLE(t,12,r),u.set(t,c),c+=t.length}(s[i]);await y.write(u),await i.endWriteSection(y)}async function K(t,e,a,n){let o=w[e];te(a.length),await i.startWriteSection(y,t);let l=[],s=0;for(;s<a.length;){let t=0;for(;s<a.length&&t<w.tm.concurrency;){r&&r.debug(`Writing points start ${n}: ${s}/${a.length}`);let i=1,o=a[s]?a[s].length:0;for(;s+i<a.length&&o+(a[s+i]?a[s+i].length:0)<32768&&i<32768;)o+=a[s+i]?a[s+i].length:0,i++;let u=a.slice(s,s+i),d=s;l.push(X(e,u,r,n).then(t=>(r&&r.debug(`Writing points end ${n}: ${d}/${a.length}`),t))),s+=i,t++}let i=await Promise.all(l);for(let t=0;t<i.length;t++){await y.write(i[t][0]);let e=await o.batchLEMtoU(i[t][0]);d.update(e)}l=[]}await i.endWriteSection(y)}async function X(t,e,a,i){let r,o,l,s,u,d;let f=w[t],c=2*f.F.n8,g=3*f.F.n8,h=2*f.F.n8;if("G1"==t)r="g1m_timesScalarAffine",o="g1m_multiexpAffine",l="g1m_batchToAffine",s="g1m_zero";else if("G2"==t)r="g2m_timesScalarAffine",o="g2m_multiexpAffine",l="g2m_batchToAffine",s="g2m_zero";else throw Error("Invalid group");let m=0;for(let t=0;t<e.length;t++)m+=e[t]?e[t].length:0;m>32768?(u=new n.BigBuffer(m*c),d=new n.BigBuffer(m*w.Fr.n8)):(u=new Uint8Array(m*c),d=new Uint8Array(m*w.Fr.n8));let b=0,p=0,y=[V,N,Q,j],S=new Uint8Array(w.Fr.n8);w.Fr.toRprLE(S,0,w.Fr.e(1));let v=0;for(let t=0;t<e.length;t++)if(e[t])for(let n=0;n<e[t].length;n++)a&&n&&n%1e4==0&&a.debug(`Configuring big array ${i}: ${n}/${e[t].length}`),u.set(y[e[t][n][0]].slice(e[t][n][1],e[t][n][1]+c),v*c),e[t][n][2]>=0?d.set(k.slice(e[t][n][2],e[t][n][2]+w.Fr.n8),v*w.Fr.n8):d.set(S,v*w.Fr.n8),v++;if(e.length>1){let t=[];t.push({cmd:"ALLOCSET",var:0,buff:u}),t.push({cmd:"ALLOCSET",var:1,buff:d}),t.push({cmd:"ALLOC",var:2,len:e.length*g}),b=0,p=0;let a=0;for(let i=0;i<e.length;i++){if(!e[i]){t.push({cmd:"CALL",fnName:s,params:[{var:2,offset:a}]}),a+=g;continue}1==e[i].length?t.push({cmd:"CALL",fnName:r,params:[{var:0,offset:b},{var:1,offset:p},{val:w.Fr.n8},{var:2,offset:a}]}):t.push({cmd:"CALL",fnName:o,params:[{var:0,offset:b},{var:1,offset:p},{val:w.Fr.n8},{val:e[i].length},{var:2,offset:a}]}),b+=c*e[i].length,p+=w.Fr.n8*e[i].length,a+=g}t.push({cmd:"CALL",fnName:l,params:[{var:2},{val:e.length},{var:2}]}),t.push({cmd:"GET",out:0,var:2,len:e.length*h});let i=await w.tm.queueAction(t);return i}{let t=await f.multiExpAffine(u,d,a,i);return[f.toAffine(t)]}}async function Y(){te(F-1);for(let t=0;t<F-1;t+=16384){r&&r.debug(`HashingHPoints: ${t}/${F}`);let e=Math.min(F-1,16384);await J(t,e)}}async function J(t,e){let a=await f.read(e*S,c[2][0].p+(t+F)*S),i=await f.read(e*S,c[2][0].p+t*S),n=w.tm.concurrency,r=Math.floor(e/n),o=[];for(let t=0;t<n;t++){let l;if(0==(l=t<n-1?r:e-t*r))continue;let s=a.slice(t*r*S,(t*r+l)*S),u=i.slice(t*r*S,(t*r+l)*S);o.push(tt(s,u))}let l=await Promise.all(o);for(let t=0;t<l.length;t++)d.update(l[t][0])}async function tt(t,e){let a=t.byteLength/S,i=3*w.G1.F.n8,n=[];n.push({cmd:"ALLOCSET",var:0,buff:t}),n.push({cmd:"ALLOCSET",var:1,buff:e}),n.push({cmd:"ALLOC",var:2,len:a*i});for(let t=0;t<a;t++)n.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:t*S},{var:1,offset:t*S},{var:2,offset:t*i}]});n.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"GET",out:0,var:2,len:a*S});let r=await w.tm.queueAction(n);return r}function te(t){let e=new Uint8Array(4),a=new DataView(e.buffer,e.byteOffset,e.byteLength);a.setUint32(0,t,!1),d.update(e)}}async function tZ(t,e,a){let i,n,r,o,l,s;let{fd:u,sections:d}=await g.readBinFile(t,"zkey",2),f=await N(u,d);if("groth16"!=f.protocol)throw Error("zkey file is not groth16");let c=await E(f.q),w=2*c.G1.F.n8,h=2*c.G2.F.n8,m=await K(u,c,d),p=await b.createOverride(e);await S(f.vk_alpha_1),await S(f.vk_beta_1),await v(f.vk_beta_2),await v(f.vk_gamma_2),await S(f.vk_delta_1),await v(f.vk_delta_2),i=await g.readSection(u,d,3),i=await c.G1.batchLEMtoU(i),await x("G1",i);let y=await g.readSection(u,d,9);n=await c.G1.fft(y,"affine","jacobian",a),n=(n=await c.G1.batchApplyKey(n,c.Fr.neg(c.Fr.e(2)),c.Fr.w[f.power+1],"jacobian","affine",a)).slice(0,n.byteLength-w),n=await c.G1.batchLEMtoU(n),await x("G1",n),r=await g.readSection(u,d,8),r=await c.G1.batchLEMtoU(r),await x("G1",r),o=await g.readSection(u,d,5),o=await c.G1.batchLEMtoU(o),await x("G1",o),l=await g.readSection(u,d,6),l=await c.G1.batchLEMtoU(l),await x("G1",l),s=await g.readSection(u,d,7),s=await c.G2.batchLEMtoU(s),await x("G2",s),await p.write(m.csHash),await C(m.contributions.length);for(let t=0;t<m.contributions.length;t++){let e=m.contributions[t];await S(e.deltaAfter),await S(e.delta.g1_s),await S(e.delta.g1_sx),await v(e.delta.g2_spx),await p.write(e.transcript)}async function S(t){let e=new Uint8Array(w);c.G1.toRprUncompressed(e,0,t),await p.write(e)}async function v(t){let e=new Uint8Array(h);c.G2.toRprUncompressed(e,0,t),await p.write(e)}async function x(t,e){let a=new Uint8Array(4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);i.setUint32(0,e.byteLength/("G1"==t?w:h),!1),await p.write(a),await p.write(e)}async function C(t){let e=new Uint8Array(4),a=new DataView(e.buffer,e.byteOffset,e.byteLength);a.setUint32(0,t,!1),await p.write(e)}await u.close(),await p.close()}async function tD(t,e,a,i,n){let r,o;let{fd:l,sections:s}=await g.readBinFile(t,"zkey",2),u=await N(l,s,!1);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");let d=await E(u.q),f=2*d.G1.F.n8,c=2*d.G2.F.n8,w=await K(l,d,s),h={},m=await b.readExisting(e);m.pos=3*f+3*c+8+f*u.nVars+4+f*(u.domainSize-1)+4+f*u.nVars+4+f*u.nVars+4+c*u.nVars,h.csHash=await m.read(64);let p=await m.readUBE32();h.contributions=[];for(let t=0;t<p;t++){let e={delta:{}};e.deltaAfter=await R(m),e.delta.g1_s=await R(m),e.delta.g1_sx=await R(m),e.delta.g2_spx=await U(m),e.transcript=await m.read(64),t<w.contributions.length&&(e.type=w.contributions[t].type,1==e.type&&(e.beaconHash=w.contributions[t].beaconHash,e.numIterationsExp=w.contributions[t].numIterationsExp),w.contributions[t].name&&(e.name=w.contributions[t].name)),h.contributions.push(e)}if(!T(h.csHash,w.csHash))return n&&n.error("Hash of the original circuit does not match with the MPC one"),!1;if(w.contributions.length>h.contributions.length)return n&&n.error("The impoerted file does not include new contributions"),!1;for(let t=0;t<w.contributions.length;t++){var y,S;if(y=w.contributions[t],S=h.contributions[t],!(d.G1.eq(y.deltaAfter,S.deltaAfter)&&d.G1.eq(y.delta.g1_s,S.delta.g1_s)&&d.G1.eq(y.delta.g1_sx,S.delta.g1_sx)&&d.G2.eq(y.delta.g2_spx,S.delta.g2_spx)&&T(y.transcript,S.transcript)))return n&&n.error(`Previos contribution ${t} does not match`),!1}if(i)for(let t=w.contributions.length;t<h.contributions.length;t++)h.contributions[t].name=i;let v=await g.createBinFile(a,"zkey",1,10);m.pos=0,m.pos+=f,m.pos+=f,m.pos+=c,m.pos+=c,u.vk_delta_1=await R(m),u.vk_delta_2=await U(m),await O(v,u);let x=await m.readUBE32();if(x!=u.nPublic+1)return n&&n.error("Invalid number of points in IC"),await v.discard(),!1;m.pos+=f*(u.nPublic+1),await g.copySection(l,s,v,3),await g.copySection(l,s,v,4);let C=await m.readUBE32();if(C!=u.domainSize-1)return n&&n.error("Invalid number of points in H"),await v.discard(),!1;let F=await m.read(f*(u.domainSize-1)),G=await d.G1.batchUtoLEM(F);(r=new Uint8Array(u.domainSize*f)).set(G),d.G1.toRprLEM(r,f*(u.domainSize-1),d.G1.zeroAffine);let B=d.Fr.neg(d.Fr.inv(d.Fr.e(2))),_=d.Fr.inv(d.Fr.w[u.power+1]);r=await d.G1.batchApplyKey(r,B,_,"affine","jacobian",n),r=await d.G1.ifft(r,"jacobian","affine",n),await g.startWriteSection(v,9),await v.write(r),await g.endWriteSection(v);let L=await m.readUBE32();if(L!=u.nVars-u.nPublic-1)return n&&n.error("Invalid number of points in L"),await v.discard(),!1;o=await m.read(f*(u.nVars-u.nPublic-1)),o=await d.G1.batchUtoLEM(o),await g.startWriteSection(v,8),await v.write(o),await g.endWriteSection(v);let A=await m.readUBE32();if(A!=u.nVars)return n&&n.error("Invalid number of points in A"),await v.discard(),!1;m.pos+=f*u.nVars,await g.copySection(l,s,v,5);let z=await m.readUBE32();if(z!=u.nVars)return n&&n.error("Invalid number of points in B1"),await v.discard(),!1;m.pos+=f*u.nVars,await g.copySection(l,s,v,6);let P=await m.readUBE32();if(P!=u.nVars)return n&&n.error("Invalid number of points in B2"),await v.discard(),!1;return m.pos+=c*u.nVars,await g.copySection(l,s,v,7),await Y(v,d,h),await m.close(),await v.close(),await l.close(),!0;async function R(t){let e=await t.read(2*d.G1.F.n8);return d.G1.fromRprUncompressed(e,0)}async function U(t){let e=await t.read(2*d.G2.F.n8);return d.G2.fromRprUncompressed(e,0)}}async function tK(t,e,a,i){await h.default.ready();let{fd:r,sections:o}=await g.readBinFile(a,"zkey",2),l=await N(r,o,!1);if("groth16"!=l.protocol)throw Error("zkey file is not groth16");let s=await E(l.q),u=2*s.G1.F.n8,d=await K(r,s,o),f=h.default(64);f.update(d.csHash);let c=s.G1.g;for(let t=0;t<d.contributions.length;t++){let e=d.contributions[t],a=function(t){let e=t.getPartialHash(),a=h.default(64);return a.setPartialHash(e),a}(f);if(J(a,s,e.delta.g1_s),J(a,s,e.delta.g1_sx),!T(a.digest(),e.transcript))return console.log(`INVALID(${t}): Inconsistent transcript `),!1;let i=tp(s,e.transcript);if(!0!==await L(s,e.delta.g1_s,e.delta.g1_sx,i,e.delta.g2_spx))return console.log(`INVALID(${t}): public key G1 and G2 do not have the same ration `),!1;if(!0!==await L(s,c,e.deltaAfter,i,e.delta.g2_spx))return console.log(`INVALID(${t}): deltaAfter does not fillow the public key `),!1;if(1==e.type){let a=await U(e.beaconHash,e.numIterationsExp),i=s.Fr.fromRng(a),n=s.G1.toAffine(s.G1.fromRng(a)),r=s.G1.toAffine(s.G1.timesFr(n,i));if(!0!==s.G1.eq(n,e.delta.g1_s))return console.log(`INVALID(${t}): Key of the beacon does not match. g1_s `),!1;if(!0!==s.G1.eq(r,e.delta.g1_sx))return console.log(`INVALID(${t}): Key of the beacon does not match. g1_sx `),!1}tt(f,s,e);let n=h.default(64);tt(n,s,e),e.contributionHash=n.digest(),c=e.deltaAfter}let{fd:w,sections:m}=await g.readBinFile(t,"zkey",2),b=await N(w,m,!1);if("groth16"!=b.protocol)throw Error("zkeyinit file is not groth16");if(!n.Scalar.eq(b.q,l.q)||!n.Scalar.eq(b.r,l.r)||b.n8q!=l.n8q||b.n8r!=l.n8r)return i&&i.error("INVALID:  Different curves"),!1;if(b.nVars!=l.nVars||b.nPublic!=l.nPublic||b.domainSize!=l.domainSize)return i&&i.error("INVALID:  Different circuit parameters"),!1;if(!s.G1.eq(l.vk_alpha_1,b.vk_alpha_1))return i&&i.error("INVALID:  Invalid alpha1"),!1;if(!s.G1.eq(l.vk_beta_1,b.vk_beta_1))return i&&i.error("INVALID:  Invalid beta1"),!1;if(!s.G2.eq(l.vk_beta_2,b.vk_beta_2))return i&&i.error("INVALID:  Invalid beta2"),!1;if(!s.G2.eq(l.vk_gamma_2,b.vk_gamma_2))return i&&i.error("INVALID:  Invalid gamma2"),!1;if(!s.G1.eq(l.vk_delta_1,c))return i&&i.error("INVALID:  Invalid delta1"),!1;if(!0!==await L(s,s.G1.g,c,s.G2.g,l.vk_delta_2))return i&&i.error("INVALID:  Invalid delta2"),!1;let p=await K(w,s,m);if(!T(d.csHash,p.csHash))return i&&i.error("INVALID:  Circuit does not match"),!1;if(o[8][0].size!=u*(l.nVars-l.nPublic-1))return i&&i.error("INVALID:  Invalid L section size"),!1;if(o[9][0].size!=u*l.domainSize)return i&&i.error("INVALID:  Invalid H section size"),!1;if(!await g.sectionIsEqual(r,o,w,m,3))return i&&i.error("INVALID:  IC section is not identical"),!1;if(!await g.sectionIsEqual(r,o,w,m,4))return i&&i.error("Coeffs section is not identical"),!1;if(!await g.sectionIsEqual(r,o,w,m,5))return i&&i.error("A section is not identical"),!1;if(!await g.sectionIsEqual(r,o,w,m,6))return i&&i.error("B1 section is not identical"),!1;if(!await g.sectionIsEqual(r,o,w,m,7))return i&&i.error("B2 section is not identical"),!1;if(!0!==await y("G1",w,m,r,o,8,l.vk_delta_2,b.vk_delta_2,"L section"))return i&&i.error("L section does not match"),!1;if(!0!==await S())return i&&i.error("H section does not match"),!1;i&&i.info(_(d.csHash,"Circuit Hash: ")),await r.close(),await w.close();for(let t=d.contributions.length-1;t>=0;t--){let e=d.contributions[t];i&&i.info("-------------------------"),i&&i.info(_(e.contributionHash,`contribution #${t+1} ${e.name?e.name:""}:`)),1==e.type&&(i&&i.info(`Beacon generator: ${k(e.beaconHash)}`),i&&i.info(`Beacon iterations Exp: ${e.numIterationsExp}`))}return i&&i.info("-------------------------"),i&&i.info("ZKey Ok!"),!0;async function y(t,e,a,n,r,o,l,u,d){let f=s[t],c=2*f.F.n8;await g.startReadUniqueSection(e,a,o),await g.startReadUniqueSection(n,r,o);let w=f.zero,h=f.zero,m=a[o][0].size/c;for(let t=0;t<m;t+=1048576){i&&i.debug(`Same ratio check ${d}:  ${t}/${m}`);let a=Math.min(m-t,1048576),r=await e.read(a*c),o=await n.read(a*c),l=A(4*a),s=await f.multiExpAffine(r,l),u=await f.multiExpAffine(o,l);w=f.add(w,s),h=f.add(h,u)}return await g.endReadSection(e),await g.endReadSection(n),0==m||!0===await L(s,w,h,l,u)}async function S(){let t;let a=s.G1,u=s.Fr,d=2*a.F.n8,{fd:f,sections:c}=await g.readBinFile(e,"ptau",1),w=new n.BigBuffer(l.domainSize*l.n8r),h=Array(8);for(let t=0;t<8;t++)h[t]=P(A(4),0);let m=new n.ChaCha(h);for(let t=0;t<l.domainSize-1;t++){let e=u.fromRng(m);u.toRprLE(w,t*l.n8r,e)}u.toRprLE(w,(l.domainSize-1)*l.n8r,u.zero);let p=a.zero;for(let t=0;t<l.domainSize;t+=1048576){i&&i.debug(`H Verificaition(tau):  ${t}/${l.domainSize}`);let e=Math.min(l.domainSize-t,1048576),n=await f.read(d*e,c[2][0].p+l.domainSize*d+t*d),r=await f.read(d*e,c[2][0].p+t*d),o=await v(n,r),s=w.slice(t*l.n8r,(t+e)*l.n8r),u=await a.multiExpAffine(o,s);p=a.add(p,u)}if(w=await u.batchToMontgomery(w),l.power<u.s)t=u.neg(u.e(2));else{let e=2**u.s,a=u.exp(u.shift,e);t=u.sub(a,u.one)}let y=l.power<u.s?u.w[l.power+1]:u.shift;w=await u.batchApplyKey(w,t,y),w=await u.fft(w),w=await u.batchFromMontgomery(w),await g.startReadUniqueSection(r,o,9);let S=a.zero;for(let t=0;t<l.domainSize;t+=1048576){i&&i.debug(`H Verificaition(lagrange):  ${t}/${l.domainSize}`);let e=Math.min(l.domainSize-t,1048576),n=await r.read(d*e),o=w.slice(t*l.n8r,(t+e)*l.n8r),s=await a.multiExpAffine(n,o);S=a.add(S,s)}return await g.endReadSection(r),!0===await L(s,p,S,l.vk_delta_2,b.vk_delta_2)}async function v(t,e){let a=2*s.G1.F.n8,i=t.byteLength/a,n=s.tm.concurrency,r=Math.floor(i/n),o=[];for(let a=0;a<n;a++){let l;if(0==(l=a<n-1?r:i-a*r))continue;let s=t.slice(a*r*u,(a*r+l)*u),d=e.slice(a*r*u,(a*r+l)*u);o.push(x(s,d))}let l=await Promise.all(o),d=new Uint8Array(i*a),f=0;for(let t=0;t<l.length;t++)d.set(l[t][0],f),f+=l[t][0].byteLength;return d}async function x(t,e){let a=2*s.G1.F.n8,i=3*s.G1.F.n8,n=t.byteLength/a,r=[];r.push({cmd:"ALLOCSET",var:0,buff:t}),r.push({cmd:"ALLOCSET",var:1,buff:e}),r.push({cmd:"ALLOC",var:2,len:n*i});for(let t=0;t<n;t++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:t*a},{var:1,offset:t*a},{var:2,offset:t*i}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:n},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:n*a});let o=await s.tm.queueAction(r);return o}}async function tX(t,e,a,i){let n={type:"bigMem"};return await tH(t,e,n,i),await tK(n,e,a,i)}async function tY(t,e,a,i,n){await h.default.ready();let{fd:r,sections:o}=await g.readBinFile(t,"zkey",2),l=await N(r,o);if("groth16"!=l.protocol)throw Error("zkey file is not groth16");let s=await E(l.q),u=await K(r,s,o),d=await g.createBinFile(e,"zkey",1,10),f=await R(i),c=h.default(64);c.update(u.csHash);for(let t=0;t<u.contributions.length;t++)tt(c,s,u.contributions[t]);let w={};w.delta={},w.delta.prvKey=s.Fr.fromRng(f),w.delta.g1_s=s.G1.toAffine(s.G1.fromRng(f)),w.delta.g1_sx=s.G1.toAffine(s.G1.timesFr(w.delta.g1_s,w.delta.prvKey)),J(c,s,w.delta.g1_s),J(c,s,w.delta.g1_sx),w.transcript=c.digest(),w.delta.g2_sp=tp(s,w.transcript),w.delta.g2_spx=s.G2.toAffine(s.G2.timesFr(w.delta.g2_sp,w.delta.prvKey)),l.vk_delta_1=s.G1.timesFr(l.vk_delta_1,w.delta.prvKey),l.vk_delta_2=s.G2.timesFr(l.vk_delta_2,w.delta.prvKey),w.deltaAfter=l.vk_delta_1,w.type=0,a&&(w.name=a),u.contributions.push(w),await O(d,l),await g.copySection(r,o,d,3),await g.copySection(r,o,d,4),await g.copySection(r,o,d,5),await g.copySection(r,o,d,6),await g.copySection(r,o,d,7);let m=s.Fr.inv(w.delta.prvKey);await tU(r,o,d,8,s,"G1",m,s.Fr.e(1),"L Section",n),await tU(r,o,d,9,s,"G1",m,s.Fr.e(1),"H Section",n),await Y(d,s,u),await r.close(),await d.close();let b=h.default(64);tt(b,s,w);let p=b.digest();return n&&n.info(_(u.csHash,"Circuit Hash: ")),n&&n.info(_(p,"Contribution Hash: ")),p}async function tJ(t,e,a,i,n,r){await h.default.ready();let o=$(i);if(0==o.byteLength||2*o.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;let{fd:l,sections:s}=await g.readBinFile(t,"zkey",2),u=await N(l,s);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");let d=await E(u.q),f=await K(l,d,s),c=await g.createBinFile(e,"zkey",1,10),w=await U(o,n),m=h.default(64);m.update(f.csHash);for(let t=0;t<f.contributions.length;t++)tt(m,d,f.contributions[t]);let b={};b.delta={},b.delta.prvKey=d.Fr.fromRng(w),b.delta.g1_s=d.G1.toAffine(d.G1.fromRng(w)),b.delta.g1_sx=d.G1.toAffine(d.G1.timesFr(b.delta.g1_s,b.delta.prvKey)),J(m,d,b.delta.g1_s),J(m,d,b.delta.g1_sx),b.transcript=m.digest(),b.delta.g2_sp=tp(d,b.transcript),b.delta.g2_spx=d.G2.toAffine(d.G2.timesFr(b.delta.g2_sp,b.delta.prvKey)),u.vk_delta_1=d.G1.timesFr(u.vk_delta_1,b.delta.prvKey),u.vk_delta_2=d.G2.timesFr(u.vk_delta_2,b.delta.prvKey),b.deltaAfter=u.vk_delta_1,b.type=1,b.numIterationsExp=n,b.beaconHash=o,a&&(b.name=a),f.contributions.push(b),await O(c,u),await g.copySection(l,s,c,3),await g.copySection(l,s,c,4),await g.copySection(l,s,c,5),await g.copySection(l,s,c,6),await g.copySection(l,s,c,7);let p=d.Fr.inv(b.delta.prvKey);await tU(l,s,c,8,d,"G1",p,d.Fr.e(1),"L Section",r),await tU(l,s,c,9,d,"G1",p,d.Fr.e(1),"H Section",r),await Y(c,d,f),await l.close(),await c.close();let y=h.default(64);tt(y,d,b);let S=y.digest();return r&&r.info(_(S,"Contribution Hash: ")),S}async function t1(t){let e=await Z(t,!0);return delete e.curve,delete e.F,n.utils.stringifyBigInts(e)}async function t2(t,e,a,i,n){await h.default.ready();let r=await R(i),o=t.Fr.fromRng(r),l=t.Fr.inv(o),s=2*t.G1.F.n8,u=2*t.G2.F.n8,d=await b.readExisting(e),f=await b.createOverride(a);await A(s),await A(s),await A(u),await A(u);let c=await z(),w=t.G1.timesFr(c,o);await U(w);let g=await P(),m=t.G2.timesFr(g,o);await $(m);let p=await d.readUBE32();await f.writeUBE32(p),await A(p*s);let y=await d.readUBE32();await f.writeUBE32(y),await t$(d,f,null,t,"G1",y,l,t.Fr.e(1),"UNCOMPRESSED","H",n);let S=await d.readUBE32();await f.writeUBE32(S),await t$(d,f,null,t,"G1",S,l,t.Fr.e(1),"UNCOMPRESSED","L",n);let v=await d.readUBE32();await f.writeUBE32(v),await A(v*s);let x=await d.readUBE32();await f.writeUBE32(x),await A(x*s);let C=await d.readUBE32();await f.writeUBE32(C),await A(C*u);let F=h.default(64),E={};E.csHash=await d.read(64),F.update(E.csHash);let G=await d.readUBE32();E.contributions=[];for(let e=0;e<G;e++){let e={delta:{}};e.deltaAfter=await z(),e.delta.g1_s=await z(),e.delta.g1_sx=await z(),e.delta.g2_spx=await P(),e.transcript=await d.read(64),E.contributions.push(e),tt(F,t,e)}let B={};B.delta={},B.delta.prvKey=o,B.delta.g1_s=t.G1.toAffine(t.G1.fromRng(r)),B.delta.g1_sx=t.G1.toAffine(t.G1.timesFr(B.delta.g1_s,o)),J(F,t,B.delta.g1_s),J(F,t,B.delta.g1_sx),B.transcript=F.digest(),B.delta.g2_sp=tp(t,B.transcript),B.delta.g2_spx=t.G2.toAffine(t.G2.timesFr(B.delta.g2_sp,o)),B.deltaAfter=w,B.type=0,E.contributions.push(B),await f.write(E.csHash),await f.writeUBE32(E.contributions.length);for(let t=0;t<E.contributions.length;t++){let e=E.contributions[t];await U(e.deltaAfter),await U(e.delta.g1_s),await U(e.delta.g1_sx),await $(e.delta.g2_spx),await f.write(e.transcript)}let T=h.default(64);tt(T,t,B);let L=T.digest();return n&&n.info(_(L,"Contribution Hash: ")),await f.close(),await d.close(),L;async function A(t){let e=2*d.pageSize;for(let a=0;a<t;a+=e){let i=Math.min(t-a,e),n=await d.read(i);await f.write(n)}}async function z(){let e=await d.read(2*t.G1.F.n8);return t.G1.fromRprUncompressed(e,0)}async function P(){let e=await d.read(2*t.G2.F.n8);return t.G2.fromRprUncompressed(e,0)}async function U(e){let a=new Uint8Array(s);t.G1.toRprUncompressed(a,0,e),await f.write(a)}async function $(e){let a=new Uint8Array(u);t.G2.toRprUncompressed(a,0,e),await f.write(a)}}let{stringifyBigInts:t0}=n.utils;async function t8(t,e){let a;e&&e.info("EXPORT VERIFICATION KEY STARTED");let{fd:i,sections:n}=await g.readBinFile(t,"zkey",2),r=await N(i,n);if(e&&e.info("> Detected protocol: "+r.protocol),"groth16"===r.protocol)a=await t3(r,i,n);else if("plonk"===r.protocol)a=await t4(r);else if(r.protocolId&&10===r.protocolId)a=await t7(r);else throw Error("zkey file protocol unrecognized");return await i.close(),e&&e.info("EXPORT VERIFICATION KEY FINISHED"),a}async function t3(t,e,a){let i=await E(t.q),n=2*i.G1.F.n8,r=await i.pairing(t.vk_alpha_1,t.vk_beta_2),o={protocol:t.protocol,curve:i.name,nPublic:t.nPublic,vk_alpha_1:i.G1.toObject(t.vk_alpha_1),vk_beta_2:i.G2.toObject(t.vk_beta_2),vk_gamma_2:i.G2.toObject(t.vk_gamma_2),vk_delta_2:i.G2.toObject(t.vk_delta_2),vk_alphabeta_12:i.Gt.toObject(r)};await g.startReadUniqueSection(e,a,3),o.IC=[];for(let a=0;a<=t.nPublic;a++){let t=await e.read(n),a=i.G1.toObject(t);o.IC.push(a)}return await g.endReadSection(e),o=t0(o)}async function t4(t){let e=await E(t.q);return t0({protocol:t.protocol,curve:e.name,nPublic:t.nPublic,power:t.power,k1:e.Fr.toObject(t.k1),k2:e.Fr.toObject(t.k2),Qm:e.G1.toObject(t.Qm),Ql:e.G1.toObject(t.Ql),Qr:e.G1.toObject(t.Qr),Qo:e.G1.toObject(t.Qo),Qc:e.G1.toObject(t.Qc),S1:e.G1.toObject(t.S1),S2:e.G1.toObject(t.S2),S3:e.G1.toObject(t.S3),X_2:e.G2.toObject(t.X_2),w:e.Fr.toObject(e.Fr.w[t.power])})}async function t7(t,e){let a=await E(t.q);return t0({protocol:t.protocol,curve:a.name,nPublic:t.nPublic,power:t.power,k1:a.Fr.toObject(t.k1),k2:a.Fr.toObject(t.k2),w:a.Fr.toObject(a.Fr.w[t.power]),w3:a.Fr.toObject(t.w3),w4:a.Fr.toObject(t.w4),w8:a.Fr.toObject(t.w8),wr:a.Fr.toObject(t.wr),X_2:a.G2.toObject(t.X_2),C0:a.G1.toObject(t.C0)})}let{unstringifyBigInts:t6,stringifyBigInts:t5}=n.utils;async function t9(t,e,a){a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");let i=await G(t.curve),n=u(t.w3);t.w3_2=d(i.Fr.square(n));let r=u(t.w4);t.w4_2=d(i.Fr.square(r)),t.w4_3=d(i.Fr.mul(i.Fr.square(r),r));let o=u(t.w8),l=i.Fr.one;for(let e=1;e<8;e++)l=i.Fr.mul(l,o),t["w8_"+e]=d(l);let s=e[t.protocol];return a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),p.default.render(s,t);function u(t){let e=t6(t);return i.Fr.fromObject(e)}function d(t){let e=i.Fr.toObject(t);return t5(e)}}async function et(t,e,a){let i=await t8(t,a);if("fflonk"===i.protocol)return t9(i,e,a);let n=e[i.protocol];return p.default.render(n,i)}var ee=Object.freeze({__proto__:null,newZKey:tH,exportBellman:tZ,importBellman:tD,verifyFromR1cs:tX,verifyFromInit:tK,contribute:tY,beacon:tJ,exportJson:t1,bellmanContribute:t2,exportVerificationKey:t8,exportSolidityVerifier:et});async function ea(t,e,a,r){globalThis.gc&&globalThis.gc(),await h.default.ready();let{fd:o,sections:l}=await i.readBinFile(e,"ptau",1,4194304,16777216),{curve:s,power:d}=await tC(o,l),{fd:f,sections:c}=await i.readBinFile(t,"r1cs",1,4194304,16777216),w=await u.readR1csFd(f,c,{loadConstraints:!0,loadCustomGates:!0}),g=2*s.G1.F.n8,m=s.G1,b=2*s.G2.F.n8,p=s.Fr,y=s.Fr.n8;r&&r.info("Reading r1cs"),await i.readSection(f,c,2);let S=new tj,v=new tj,x=w.nVars,C=w.nOutputs+w.nPubInputs;await R(s.Fr,w,r),globalThis.gc&&globalThis.gc();let F=await i.createBinFile(a,"zkey",1,14,4194304,16777216);if(w.prime!=s.r)return r&&r.error("r1cs curve does not match powers of tau ceremony curve"),-1;let E=B(S.length-1)+1;E<3&&(E=3);let G=2**E;if(r&&r.info("Plonk constraints: "+S.length),E>d)return r&&r.error(`circuit too big for this power of tau ceremony. ${S.length} > 2**${d}`),-1;if(!l[12])return r&&r.error("Powers of tau is not prepared."),-1;let _=new n.BigBuffer(G*g),T=l[12][0].p+(2**E-1)*g;await o.readToBuffer(_,0,G*g,T);let[L,A]=function(){let t=p.two;for(;a(t,[],E);)p.add(t,p.one);let e=p.add(t,p.one);for(;a(e,[t],E);)p.add(e,p.one);return[t,e];function a(t,e,a){let i=2**a,n=p.one;for(let r=0;r<i;r++){if(p.eq(t,n))return!0;for(let a=0;a<e.length;a++)if(p.eq(t,p.mul(e[a],n)))return!0;n=p.mul(n,p.w[a])}return!1}}(),z={};await I(3,"Additions"),globalThis.gc&&globalThis.gc(),await U(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await U(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await U(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await $(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await $(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await $(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await $(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await $(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await O(12,"sigma"),globalThis.gc&&globalThis.gc(),await q(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await i.startWriteSection(F,14);let P=new n.BigBuffer((G+6)*g);async function R(t,e,a){function i(t){let e=Object.keys(t);for(let a=0;a<e.length;a++)0n==t[e[a]]&&delete t[e[a]]}function n(e,a,n){let r={};for(let i in e)void 0===r[i]?r[i]=t.mul(a,e[i]):r[i]=t.add(r[i],t.mul(a,e[i]));for(let e in n)void 0===r[e]?r[e]=n[e]:r[e]=t.add(r[e],n[e]);return i(r),r}function r(e,a){let i={k:t.zero,s:[],coefs:[]},n=[];for(let a in e)0==a?i.k=t.add(i.k,e[a]):0n!=e[a]&&n.push([Number(a),e[a]]);for(;n.length>a;){let e=n.shift(),a=n.shift(),i=e[0],r=a[0],o=x++,l=t.zero,s=t.neg(e[1]),u=t.neg(a[1]),d=t.one,f=t.zero;S.push([i,r,o,l,s,u,d,f]),v.push([i,r,e[1],a[1]]),n.push([o,t.one])}for(let t=0;t<n.length;t++)i.s[t]=n[t][0],i.coefs[t]=n[t][1];for(;i.coefs.length<a;)i.s.push(0),i.coefs.push(t.zero);return i}function o(e){let a=r(e,3),i=a.s[0],n=a.s[1],o=a.s[2],l=t.zero,s=a.coefs[0],u=a.coefs[1],d=a.coefs[2],f=a.k;S.push([i,n,o,l,s,u,d,f])}function l(e){let a=t.zero,i=0,n=Object.keys(e);for(let r=0;r<n.length;r++)0n==e[n[r]]?delete e[n[r]]:0==n[r]?a=t.add(a,e[n[r]]):i++;return i>0?i.toString():a!=t.zero?"k":"0"}for(let e=1;e<=C;e++){let a=e,i=t.zero,n=t.one,r=t.zero,o=t.zero,l=t.zero;S.push([a,0,0,i,n,r,o,l])}for(let s=0;s<e.constraints.length;s++)a&&s%1e4==0&&a.debug(`processing constraints: ${s}/${e.nConstraints}`),function(e,a,s){let u=l(e),d=l(a);if("0"===u||"0"===d)i(s),o(s);else if("k"===u){let t=n(a,e[0],s);o(t)}else if("k"===d){let t=n(e,a[0],s);o(t)}else!function(e,a,i){let n=r(e,1),o=r(a,1),l=r(i,1),s=n.s[0],u=o.s[0],d=l.s[0],f=t.mul(n.coefs[0],o.coefs[0]),c=t.mul(n.coefs[0],o.k),w=t.mul(n.k,o.coefs[0]),g=t.neg(l.coefs[0]),h=t.sub(t.mul(n.k,o.k),l.k);S.push([s,u,d,f,c,w,g,h])}(e,a,s)}(...e.constraints[s])}async function U(t,e,a){await i.startWriteSection(F,t);for(let t=0;t<S.length;t++)await F.writeULE32(S[t][e]),r&&t%1e6==0&&r.debug(`writing ${a}: ${t}/${S.length}`);await i.endWriteSection(F)}async function $(t,e,a){let o=new n.BigBuffer(G*y);for(let t=0;t<S.length;t++)o.set(S[t][e],t*y),r&&t%1e6==0&&r.debug(`writing ${a}: ${t}/${S.length}`);await i.startWriteSection(F,t),await k(o),await i.endWriteSection(F),o=await p.batchFromMontgomery(o),z[a]=await s.G1.multiExpAffine(_,o,r,"multiexp "+a)}async function k(t){let e=await p.ifft(t),a=new n.BigBuffer(G*y*4);a.set(e,0);let i=await p.fft(a);await F.write(e),await F.write(i)}async function I(t,e){await i.startWriteSection(F,t);let a=new Uint8Array(8+2*y),n=new DataView(a.buffer);for(let t=0;t<v.length;t++){let i=v[t],o=0;n.setUint32(o,i[0],!0),o+=4,n.setUint32(o,i[1],!0),o+=4,a.set(i[2],o),o+=y,a.set(i[3],o),o+=y,await F.write(a),r&&t%1e6==0&&r.debug(`writing ${e}: ${t}/${v.length}`)}await i.endWriteSection(F)}async function O(t,e){let a=new n.BigBuffer(y*G*3),o=new tj(x),l=new tj(x),u=p.one;for(let t=0;t<G;t++)t<S.length?(w(S[t][0],t),w(S[t][1],G+t),w(S[t][2],2*G+t)):(w(0,t),w(0,G+t),w(0,2*G+t)),u=p.mul(u,p.w[E]),r&&t%1e6==0&&r.debug(`writing ${e} phase1: ${t}/${S.length}`);for(let t=0;t<x;t++)void 0!==l[t]?a.set(o[t],l[t]*y):console.log("Variable not used"),r&&t%1e6==0&&r.debug(`writing ${e} phase2: ${t}/${x}`);globalThis.gc&&globalThis.gc(),await i.startWriteSection(F,t);let d=a.slice(0,G*y);await k(d),globalThis.gc&&globalThis.gc();let f=a.slice(G*y,G*y*2);await k(f),globalThis.gc&&globalThis.gc();let c=a.slice(G*y*2,G*y*3);function w(t,e){let i;void 0===o[t]?l[t]=e:a.set(o[t],e*y),i=e<G?u:e<2*G?p.mul(u,L):p.mul(u,A),o[t]=i}await k(c),globalThis.gc&&globalThis.gc(),await i.endWriteSection(F),d=await p.batchFromMontgomery(d),f=await p.batchFromMontgomery(f),c=await p.batchFromMontgomery(c),z.S1=await s.G1.multiExpAffine(_,d,r,"multiexp S1"),globalThis.gc&&globalThis.gc(),z.S2=await s.G1.multiExpAffine(_,f,r,"multiexp S2"),globalThis.gc&&globalThis.gc(),z.S3=await s.G1.multiExpAffine(_,c,r,"multiexp S3"),globalThis.gc&&globalThis.gc()}async function q(t,e){await i.startWriteSection(F,t);let a=Math.max(C,1);for(let t=0;t<a;t++){let i=new n.BigBuffer(G*y);i.set(p.one,t*y),await k(i),r&&r.debug(`writing ${e} ${t}/${a}`)}await i.endWriteSection(F)}async function W(){let t;await i.startWriteSection(F,1),await F.writeULE32(2),await i.endWriteSection(F),await i.startWriteSection(F,2);let e=s.q,a=(Math.floor((n.Scalar.bitLength(e)-1)/64)+1)*8,r=s.r,u=(Math.floor((n.Scalar.bitLength(r)-1)/64)+1)*8;await F.writeULE32(a),await i.writeBigInt(F,e,a),await F.writeULE32(u),await i.writeBigInt(F,r,u),await F.writeULE32(x),await F.writeULE32(C),await F.writeULE32(G),await F.writeULE32(v.length),await F.writeULE32(S.length),await F.write(L),await F.write(A),await F.write(m.toAffine(z.Qm)),await F.write(m.toAffine(z.Ql)),await F.write(m.toAffine(z.Qr)),await F.write(m.toAffine(z.Qo)),await F.write(m.toAffine(z.Qc)),await F.write(m.toAffine(z.S1)),await F.write(m.toAffine(z.S2)),await F.write(m.toAffine(z.S3)),t=await o.read(b,l[3][0].p+b),await F.write(t),await i.endWriteSection(F)}await o.readToBuffer(P,0,(G+6)*g,l[2][0].p),await F.write(P),await i.endWriteSection(F),globalThis.gc&&globalThis.gc(),await W(),await F.close(),await f.close(),await o.close(),r&&r.info("Setup Finished")}class ei{constructor(t,e){this.curve=t,this.logger=e,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(t,e){t in this.polynomials&&this.logger.warn(`proof: polynomial.${t} already exist in proof`),this.polynomials[t]=e}getPolynomial(t){return t in this.polynomials||this.logger.warn(`proof: polynomial ${t} does not exist in proof`),this.polynomials[t]}addEvaluation(t,e){t in this.evaluations&&this.logger.warn(`proof: evaluations.${t} already exist in proof`),this.evaluations[t]=e}getEvaluation(t){return t in this.evaluations||this.logger.warn(`proof: evaluation ${t} does not exist in proof`),this.evaluations[t]}toObjectProof(t=!0){let e=t?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(a=>{let i=this.curve.G1.toObject(this.polynomials[a]);t?e.polynomials[a]=i:e[a]=i}),Object.keys(this.evaluations).forEach(a=>{let i=this.curve.Fr.toObject(this.evaluations[a]);t?e.evaluations[a]=i:e[a]=i}),e}fromObjectProof(t){this.resetProof(),Object.keys(t.polynomials).forEach(e=>{this.polynomials[e]=this.curve.G1.fromObject(t.polynomials[e])}),Object.keys(t.evaluations).forEach(e=>{this.evaluations[e]=this.curve.Fr.fromObject(t.evaluations[e])})}}let{keccak256:en}=y.default;class er{constructor(t){this.G1=t.G1,this.Fr=t.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(t){this.data.push({type:0,data:t})}addScalar(t){this.data.push({type:1,data:t})}getChallenge(){if(0===this.data.length)throw Error("Keccak256Transcript: No data to generate a transcript");let t=0,e=0;this.data.forEach(a=>0===a.type?t++:e++);let a=new Uint8Array(e*this.Fr.n8+t*this.G1.F.n8*2),i=0;for(let t=0;t<this.data.length;t++)0===this.data[t].type?(this.G1.toRprUncompressed(a,i,this.data[t].data),i+=2*this.G1.F.n8):(this.Fr.toRprBE(a,i,this.data[t].data),i+=this.Fr.n8);let r=n.Scalar.fromRprBE(new Uint8Array(en.arrayBuffer(a)));return this.Fr.e(r)}}class eo{static getZ1(t){return[t.zero,t.add(t.e(-1),t.w[2]),t.e(-2),t.sub(t.e(-1),t.w[2])]}static getZ2(t){return[t.zero,t.add(t.zero,t.mul(t.e(-2),t.w[2])),t.e(4),t.sub(t.zero,t.mul(t.e(-2),t.w[2]))]}static getZ3(t){return[t.zero,t.add(t.e(2),t.mul(t.e(2),t.w[2])),t.e(-8),t.sub(t.e(2),t.mul(t.e(2),t.w[2]))]}static mul2(t,e,a,i,n,r){let o;let l=this.getZ1(r),s=r.mul(t,e),u=r.mul(t,i),d=r.mul(a,e),f=r.mul(a,i);return o=r.add(u,d),n&&(o=r.add(o,r.mul(l[n],f))),[s,o]}static mul3(t,e,a,i,n,r,o,l){let s,u;let d=this.getZ1(l),f=this.getZ2(l),c=l.mul(t,e),w=l.mul(t,n),g=l.mul(i,e),h=l.mul(i,n);s=l.mul(c,a);let m=l.mul(g,a);m=l.add(m,l.mul(w,a)),m=l.add(m,l.mul(c,r));let b=l.mul(h,a);if(b=l.add(b,l.mul(w,r)),b=l.add(b,l.mul(g,r)),u=m,o){let t=l.mul(h,r);u=l.add(u,l.mul(d[o],b)),u=l.add(u,l.mul(f[o],t))}return[s,u]}static mul4(t,e,a,i,n,r,o,l,s,u){let d,f;let c=this.getZ1(u),w=this.getZ2(u),g=this.getZ3(u),h=u.mul(t,e),m=u.mul(t,r),b=u.mul(n,e),p=u.mul(n,r),y=u.mul(a,i),S=u.mul(a,l),v=u.mul(o,i),x=u.mul(o,l);d=u.mul(h,y);let C=u.mul(b,y);C=u.add(C,u.mul(m,y)),C=u.add(C,u.mul(h,v)),C=u.add(C,u.mul(h,S));let F=u.mul(p,y);F=u.add(F,u.mul(b,v)),F=u.add(F,u.mul(b,S)),F=u.add(F,u.mul(m,v)),F=u.add(F,u.mul(m,S)),F=u.add(F,u.mul(h,x));let E=u.mul(m,x);E=u.add(E,u.mul(b,x)),E=u.add(E,u.mul(p,S)),E=u.add(E,u.mul(p,v));let G=u.mul(p,x);return f=C,s&&(f=u.add(f,u.mul(c[s],F)),f=u.add(f,u.mul(w[s],E)),f=u.add(f,u.mul(g[s],G))),[d,f]}}class el{constructor(t,e,a){this.coef=t,this.curve=e,this.Fr=e.Fr,this.G1=e.G1,this.logger=a}static async fromEvaluations(t,e,a){let i=await e.Fr.ifft(t);return new el(i,e,a)}static fromCoefficientsArray(t,e,a){let i=e.Fr,r=t.length>32768?new n.BigBuffer(t.length*i.n8):new Uint8Array(t.length*i.n8);for(let e=0;e<t.length;e++)r.set(t[e],e*i.n8);return new el(r,e,a)}static fromPolynomial(t,e,a){let i=t.length(),r=e.Fr,o=i>32768?new n.BigBuffer(i*r.n8):new Uint8Array(i*r.n8);return o.set(t.coef.slice(),0),new el(o,e,a)}isEqual(t){let e=this.degree();if(e!==t.degree())return!1;for(let a=0;a<e+1;a++)if(!this.Fr.eq(this.getCoef(a),t.getCoef(a)))return!1;return!0}blindCoefficients(t){t=t||[];let e=this.length()+t.length>32768?new n.BigBuffer((this.length()+t.length)*this.Fr.n8):new Uint8Array((this.length()+t.length)*this.Fr.n8);e.set(this.coef,0);for(let a=0;a<t.length;a++)e.set(this.Fr.add(e.slice((this.length()+a)*this.Fr.n8,(this.length()+a+1)*this.Fr.n8),t[a]),(this.length()+a)*this.Fr.n8),e.set(this.Fr.sub(e.slice(a*this.Fr.n8,(a+1)*this.Fr.n8),t[a]),a*this.Fr.n8);this.coef=e}getCoef(t){let e=t*this.Fr.n8;return e+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(e,e+this.Fr.n8)}setCoef(t,e){if(t>this.length()-1)throw Error("Coef index is not available");this.coef.set(e,t*this.Fr.n8)}static async to4T(t,e,a,i){a=a||[];let r=await i.ifft(t),o=4*e>32768?new n.BigBuffer(4*e*i.n8):new Uint8Array(4*e*i.n8);o.set(r,0);let l=await i.fft(o);if(0===a.length)return[r,l];let s=e+a.length>32768?new n.BigBuffer((e+a.length)*i.n8):new Uint8Array((e+a.length)*i.n8);s.set(r,0);for(let t=0;t<a.length;t++)s.set(i.add(s.slice((e+t)*i.n8,(e+t+1)*i.n8),a[t]),(e+t)*i.n8),s.set(i.sub(s.slice(t*i.n8,(t+1)*i.n8),a[t]),t*i.n8);return[s,l]}length(){let t=this.coef.byteLength/this.Fr.n8;if(t!==Math.floor(this.coef.byteLength/this.Fr.n8))throw Error("Polynomial coefficients buffer has incorrect size");return 0===t&&this.logger&&this.logger.warn("Polynomial has length zero"),t}degree(){for(let t=this.length()-1;t>0;t--){let e=t*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(e,e+this.Fr.n8)))return t}return 0}evaluate(t){let e=this.Fr.zero;for(let a=this.degree()+1;a>0;a--){let i=a*this.Fr.n8,n=this.coef.slice(i-this.Fr.n8,i);e=this.Fr.add(n,this.Fr.mul(e,t))}return e}fastEvaluate(t){let e=this.Fr,a=this.degree()+1,i=parseInt(a/3),n=a-3*i,r=[],o=[];o[0]=e.one;for(let a=0;a<3;a++){r[a]=e.zero;let l=2===a?i+n:i;for(let n=l;n>0;n--)r[a]=e.add(this.getCoef(a*i+n-1),e.mul(r[a],t)),0===a&&(o[0]=e.mul(o[0],t))}for(let t=1;t<3;t++)r[0]=e.add(r[0],e.mul(o[t-1],r[t])),o[t]=e.mul(o[t-1],o[0]);return r[0]}add(t,e){let a=!1;t.length()>this.length()&&(a=!0);let i=this.length(),n=t.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?t.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==e&&(s=this.Fr.mul(s,e)),a?t.coef.set(this.Fr.add(l,s),o):this.coef.set(this.Fr.add(l,s),o)}a&&(delete this.coef,this.coef=t.coef)}sub(t,e){let a=!1;t.length()>this.length()&&(a=!0);let i=this.length(),n=t.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?t.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==e&&(s=this.Fr.mul(s,e)),a?t.coef.set(this.Fr.sub(l,s),o):this.coef.set(this.Fr.sub(l,s),o)}a&&(delete this.coef,this.coef=t.coef)}mulScalar(t){for(let e=0;e<this.length();e++){let a=e*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(a,a+this.Fr.n8),t),a)}}addScalar(t){let e=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(e,t),0)}subScalar(t){let e=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(e,t),0)}byXSubValue(t){let e=this.Fr,a=!e.eq(e.zero,this.getCoef(this.length()-1)),i=a?this.length()+1:this.length(),r=i>32768?new n.BigBuffer(i*e.n8):new Uint8Array(i*e.n8),o=new el(r,this.curve,this.logger);o.coef.set(this.coef.slice(0,(i-1)*e.n8),32),this.mulScalar(e.neg(t)),o.add(this),this.coef=o.coef}byXNSubValue(t,e){let a=this.Fr,i=!(this.length()-t-1>=this.degree()),r=i?this.length()+t:this.length(),o=r>32768?new n.BigBuffer(r*a.n8):new Uint8Array(r*a.n8),l=new el(o,this.curve,this.logger);l.coef.set(this.coef.slice(0,(this.degree()+1)*32),32*t),this.mulScalar(e),l.add(this),this.coef=l.coef}divBy(t){let e=this.Fr,a=this.degree(),i=t.degree(),r=new el(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*e.n8):new Uint8Array(this.length()*e.n8);for(let n=a-i;n>=0;n--){this.setCoef(n,e.div(r.getCoef(n+i),t.getCoef(i)));for(let a=0;a<=i;a++)r.setCoef(n+a,e.sub(r.getCoef(n+a),e.mul(this.getCoef(n),t.getCoef(a))))}return r}divByMonic(t,e){let a=this.Fr,i=this.degree(),r=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8),o=new el(r,this.curve,this.logger),l=[];for(let e=0;e<t;e++)o.setCoef(i-e-t,this.getCoef(i-e)),l[e]=this.getCoef(i-e);for(let n=0;n<t;n++)for(let r=i-2*t-n;r>=0&&!(r<0);r-=t){let i=n;l[i]=a.add(this.getCoef(r+t),a.mul(l[i],e)),o.setCoef(r,l[i])}this.coef=o.coef}divByVanishing(t,e){if(this.degree()<t)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new el(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8);for(let n=this.length()-1;n>=t;n--){let r=i.getCoef(n);a.eq(a.zero,r)||(i.setCoef(n,a.zero),i.setCoef(n-t,a.add(i.getCoef(n-t),a.mul(e,r))),this.setCoef(n-t,a.add(this.getCoef(n-t),r)))}return i}divByVanishing2(t,e){if(this.degree()<t)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new el(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8);let r=this.length()-t,o=Math.floor(r/3),l=r-2*o;console.log(r),console.log(o+"  "+l);for(let n=0;n<3;n++){console.log("> Thread "+n);for(let r=0===n?l:o;r>0;r--){let s=r-1;0!==n&&(s+=(n-1)*o+l);let u=s+t,d=i.getCoef(u);a.eq(a.zero,d)||(i.setCoef(u,a.zero),i.setCoef(s,a.add(i.getCoef(s),a.mul(e,d))),this.setCoef(s,a.add(this.getCoef(s),d)),console.log(s+" <-- "+u))}}return this.print(),i}fastDivByVanishing(t){let e=this.Fr;for(let a=0;a<t.length;a++){let i=t[a][0],r=t[a][1];if(this.degree()<i)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let o=this.length()-i,l=Math.floor(o/5/i),s=l*i,u=o-5*s,d=new el(this.length()>32768?new n.BigBuffer(this.length()*e.n8):new Uint8Array(this.length()*e.n8),this.curve,this.logger),f=this.coef;this.coef=d.coef,d.coef=f;for(let t=0;t<5;t++){let a=(t+1)*s+u;for(let t=0;t<i;t++)this.setCoef(a+t-i,d.getCoef(a+t));for(let t=0;t<s-i;t++){let n=a-t-1,o=e.add(d.getCoef(n),e.mul(r,this.getCoef(n)));this.setCoef(n-i,o)}}let c=u;for(let t=0;t<i&&c;t++)this.setCoef(u-t-1,d.getCoef(u+i-t-1)),c--;for(let t=0;t<c;t++){let a=u-t-1,n=e.add(d.getCoef(a),e.mul(r,this.getCoef(a)));this.setCoef(a-i,n)}let w=[],g=e.one;for(let t=0;t<l;t++)g=e.mul(g,r);let h=e.one;for(let t=5;t>0;t--){let a=t-1,n=a*s+u;w[a]=[];for(let r=0;r<i;r++)w[a][r]=this.getCoef(n+r),5!==t&&(w[a][r]=e.add(w[a][r],e.mul(g,w[a+1][r])));h=e.mul(h,g)}for(let t=0;t<5;t++){let a=t*s+u,n=r,o=i-1,l=0===t?u:s;for(let s=0;s<l;s++){let l=a-s-1,u=e.add(this.getCoef(l),e.mul(n,w[t][o]));this.setCoef(l,u),0===o?(o=i-1,n=e.mul(n,r)):o--}}}}divByXSubValue(t){let e=this.length()>32768?new n.BigBuffer(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);e.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),e.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let a=this.length()-3;a>=0;a--){let i=a*this.Fr.n8;e.set(this.Fr.add(this.coef.slice(i+this.Fr.n8,i+2*this.Fr.n8),this.Fr.mul(t,e.slice(i+this.Fr.n8,i+2*this.Fr.n8))),a*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(t),e.slice(0,this.Fr.n8))))throw Error("Polynomial does not divide");this.coef=e}divZh(t,e=4){for(let e=0;e<t;e++){let t=e*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(t,t+this.Fr.n8)),t)}let a=this.coef.byteLength/this.Fr.n8;for(let i=t;i<a;i++){let a=i*this.Fr.n8,n=this.Fr.sub(this.coef.slice((i-t)*this.Fr.n8,(i-t)*this.Fr.n8+this.Fr.n8),this.coef.slice(a,a+this.Fr.n8));if(this.coef.set(n,a),i>t*(e-1)-e&&!this.Fr.isZero(n))throw Error("Polynomial is not divisible")}return this}divByZerofier(t,e){let a=this.Fr,i=a.inv(e),n=a.neg(i),r=a.eq(a.one,n),o=a.eq(a.negone,n);if(!r)for(let e=0;e<t;e++){let t;let i=e*this.Fr.n8;t=o?a.neg(this.coef.slice(i,i+this.Fr.n8)):a.mul(n,this.coef.slice(i,i+this.Fr.n8)),this.coef.set(t,i)}r=a.eq(a.one,i),o=a.eq(a.negone,i);for(let e=t;e<this.length();e++){let n=e*this.Fr.n8,l=(e-t)*this.Fr.n8,s=this.Fr.sub(this.coef.slice(l,l+this.Fr.n8),this.coef.slice(n,n+this.Fr.n8));if(r||(s=o?a.neg(s):a.mul(i,s)),this.coef.set(s,n),e>this.length()-t-1&&!this.Fr.isZero(s))throw Error("Polynomial is not divisible")}return this}byX(){let t=this.length()+1>32768?new n.BigBuffer(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);t.set(this.Fr.zero,0),t.set(this.coef,this.Fr.n8),this.coef=t}static;async expX(t,e,a=!1){let i=t.Fr;if(e<1)throw Error("Compute a new polynomial to a zero or negative number is not allowed");if(1===e)return await el.fromEvaluations(t.coef,curve,t.logger);let r=a?t.degree():t.length()-1,o=r*e+1>32768?new n.BigBuffer((r*e+1)*i.n8):new Uint8Array((r*e+1)*i.n8);o.set(t.getCoef(0),0);for(let a=1;a<=r;a++){let n=a*i.n8,r=t.getCoef(a);o.set(r,n*e)}return new el(o,t.curve,t.logger)}split(t,e,a){if(t<1)throw Error(`Polynomials can't be split in ${t} parts`);if(1===t)return[this];if(0!==a.length&&a.length<t-1)throw Error(`Blinding factors length must be ${t-1}`);let i=(e+1)*this.Fr.n8,r=[],o=Math.ceil((this.degree()+1)*this.Fr.n8/i);if(o<t)for(let e=o;e<t;e++)r[e]=new el(new Uint8Array(this.Fr.n8),this.curve,this.logger);t=Math.min(t,o);for(let e=0;e<t;e++){let o=t-1===e,l=o?this.coef.byteLength-(t-1)*i:i+this.Fr.n8,s=l/this.Fr.n8>32768?new n.BigBuffer(l):new Uint8Array(l);r[e]=new el(s,this.curve,this.logger);let u=e*i,d=o?this.coef.byteLength:(e+1)*i;if(r[e].coef.set(this.coef.slice(u,d),0),o||r[e].coef.set(a[e],i),0!==e){let t=this.Fr.sub(r[e].coef.slice(0,this.Fr.n8),a[e-1]);r[e].coef.set(t,0)}o&&r[e].truncate()}return r}truncate(){let t=this.degree();if(t+1<this.coef.byteLength/this.Fr.n8){let e=t+1>32768?new n.BigBuffer((t+1)*this.Fr.n8):new Uint8Array((t+1)*this.Fr.n8);e.set(this.coef.slice(0,(t+1)*this.Fr.n8),0),this.coef=e}}static lagrangePolynomialInterpolation(t,e,a){let i=a.Fr,r=o(0);for(let e=1;e<t.length;e++)r.add(o(e));return r;function o(r){let o;for(let e=0;e<t.length;e++)if(e!==r){if(void 0===o){let r=t.length>32768?new n.BigBuffer(t.length*i.n8):new Uint8Array(t.length*i.n8);(o=new el(r,a)).setCoef(0,i.neg(t[e])),o.setCoef(1,i.one)}else o.byXSubValue(t[e])}let l=o.evaluate(t[r]);l=i.inv(l);let s=i.mul(e[r],l);return o.mulScalar(s),o}}static zerofierPolynomial(t,e){let a=e.Fr,i=t.length+1>32768?new n.BigBuffer((t.length+1)*a.n8):new Uint8Array((t.length+1)*a.n8),r=new el(i,e);r.setCoef(0,a.neg(t[0])),r.setCoef(1,a.one);for(let e=1;e<t.length;e++)r.byXSubValue(t[e]);return r}print(){let t=this.Fr,e="";for(let a=this.degree();a>=0;a--){let i=this.getCoef(a);!t.eq(t.zero,i)&&(t.isNegative(i)?e+=" - ":a!==this.degree()&&(e+=" + "),e+=t.toString(i),a>0&&(e+=a>1?"x^"+a:"x"))}console.log(e)}async multiExponentiation(t,e){let a=this.coef.byteLength/this.Fr.n8,i=t.slice(0,a*this.G1.F.n8*2),n=await this.Fr.batchFromMontgomery(this.coef),r=await this.G1.multiExpAffine(i,n,this.logger,e);return this.G1.toAffine(r)}}class es{constructor(t,e,a){this.eval=t,this.curve=e,this.Fr=e.Fr,this.logger=a}static async fromPolynomial(t,e,a,i){let r=new n.BigBuffer(t.length()*e*a.Fr.n8);r.set(t.coef,0);let o=await a.Fr.fft(r);return new es(o,a,i)}getEvaluation(t){let e=t*this.Fr.n8;if(e+this.Fr.n8>this.eval.byteLength)throw Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(e,e+this.Fr.n8)}length(){let t=this.eval.byteLength/this.Fr.n8;if(t!==Math.floor(this.eval.byteLength/this.Fr.n8))throw Error("Polynomial evaluations buffer has incorrect size");return 0===t&&this.logger.warn("Polynomial has length zero"),t}}let{stringifyBigInts:eu}=n.utils;async function ed(t,e,a){let{fd:i,sections:r}=await g.readBinFile(e,"wtns",2,33554432,8388608);a&&a.debug("> Reading witness file");let o=await ti(i,r);a&&a.debug("> Reading zkey file");let{fd:l,sections:s}=await g.readBinFile(t,"zkey",2,33554432,8388608),u=await N(l,s);if("plonk"!=u.protocol)throw Error("zkey file is not plonk");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=u.nVars-u.nAdditions)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}, ${u.nAdditions}`);let d=u.curve,f=d.Fr,c=d.Fr.n8,w=u.domainSize*c;a&&(a.debug("----------------------------"),a.debug("  PLONK PROVE SETTINGS"),a.debug(`  Curve:         ${d.name}`),a.debug(`  Circuit power: ${u.power}`),a.debug(`  Domain size:   ${u.domainSize}`),a.debug(`  Vars:          ${u.nVars}`),a.debug(`  Public vars:   ${u.nPublic}`),a.debug(`  Constraints:   ${u.nConstraints}`),a.debug(`  Additions:     ${u.nAdditions}`),a.debug("----------------------------")),a&&a.debug("> Reading witness file data");let h=await g.readSection(i,r,2);h.set(f.zero,0);let m=new n.BigBuffer(c*u.nAdditions),b={},p={},y={},S={},v=new ei(d,a),x=new er(d);a&&a.debug("> Reading Section 3. Additions"),await G(),a&&a.debug("> Reading Section 12. Sigma1, Sigma2 & Sigma 3"),a&&a.debug("\xb7\xb7\xb7 Reading Sigma polynomials "),p.Sigma1=new el(new n.BigBuffer(w),d,a),p.Sigma2=new el(new n.BigBuffer(w),d,a),p.Sigma3=new el(new n.BigBuffer(w),d,a),await l.readToBuffer(p.Sigma1.coef,0,w,s[12][0].p),await l.readToBuffer(p.Sigma2.coef,0,w,s[12][0].p+5*w),await l.readToBuffer(p.Sigma3.coef,0,w,s[12][0].p+10*w),a&&a.debug("\xb7\xb7\xb7 Reading Sigma evaluations"),y.Sigma1=new es(new n.BigBuffer(4*w),d,a),y.Sigma2=new es(new n.BigBuffer(4*w),d,a),y.Sigma3=new es(new n.BigBuffer(4*w),d,a),await l.readToBuffer(y.Sigma1.eval,0,4*w,s[12][0].p+w),await l.readToBuffer(y.Sigma2.eval,0,4*w,s[12][0].p+6*w),await l.readToBuffer(y.Sigma3.eval,0,4*w,s[12][0].p+11*w),a&&a.debug("> Reading Section 14. Powers of Tau");let C=await g.readSection(l,s,14),F=[];for(let t=1;t<=u.nPublic;t++){let e=h.slice(t*f.n8,t*f.n8+f.n8);F.push(n.Scalar.fromRprLE(e))}a&&a.debug(""),a&&a.debug("> ROUND 1"),await T(),a&&a.debug("> ROUND 2"),await A(),a&&a.debug("> ROUND 3"),await P(),a&&a.debug("> ROUND 4"),await U(),a&&a.debug("> ROUND 5"),await $(),await l.close(),await i.close();let E=v.toObjectProof(!1);return E.protocol="plonk",E.curve=d.name,a&&a.debug("PLONK PROVER FINISHED"),{proof:eu(E),publicSignals:eu(F)};async function G(){a&&a.debug("\xb7\xb7\xb7 Computing additions");let t=await g.readSection(l,s,3),e=8+2*c;for(let i=0;i<u.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.debug(`    addition ${i}/${u.nAdditions}`);let n=i*e,r=B(t,n);n+=4;let o=B(t,n);n+=4;let l=t.slice(n,n+c);n+=c;let s=t.slice(n,n+c),d=_(r),w=_(o),g=f.add(f.mul(l,d),f.mul(s,w));m.set(g,c*i)}}function B(t,e){let a=t.slice(e,e+4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);return i.getUint32(0,!0)}function _(t){return t<u.nVars-u.nAdditions?h.slice(t*c,t*c+c):t<u.nVars?m.slice((t-(u.nVars-u.nAdditions))*c,(t-(u.nVars-u.nAdditions))*c+c):d.Fr.zero}async function T(){S.b=[];for(let t=1;t<=11;t++)S.b[t]=d.Fr.random();a&&a.debug("> Computing A, B, C wire polynomials"),await L(),a&&a.debug("> Computing A, B, C MSM");let t=await p.A.multiExponentiation(C,"A"),e=await p.B.multiExponentiation(C,"B"),i=await p.C.multiExponentiation(C,"C");return v.addPolynomial("A",t),v.addPolynomial("B",e),v.addPolynomial("C",i),0}async function L(){a&&a.debug("\xb7\xb7\xb7 Reading data from zkey file"),b.A=new n.BigBuffer(w),b.B=new n.BigBuffer(w),b.C=new n.BigBuffer(w);let t=await g.readSection(l,s,4),e=await g.readSection(l,s,5),i=await g.readSection(l,s,6);for(let a=0;a<u.nConstraints;a++){let n=a*c,r=4*a,o=B(t,r);b.A.set(_(o),n);let l=B(e,r);b.B.set(_(l),n);let s=B(i,r);b.C.set(_(s),n)}if(b.A=await f.batchToMontgomery(b.A),b.B=await f.batchToMontgomery(b.B),b.C=await f.batchToMontgomery(b.C),a&&a.debug("\xb7\xb7\xb7 Computing A ifft"),p.A=await el.fromEvaluations(b.A,d,a),a&&a.debug("\xb7\xb7\xb7 Computing B ifft"),p.B=await el.fromEvaluations(b.B,d,a),a&&a.debug("\xb7\xb7\xb7 Computing C ifft"),p.C=await el.fromEvaluations(b.C,d,a),a&&a.debug("\xb7\xb7\xb7 Computing A fft"),y.A=await es.fromPolynomial(p.A,4,d,a),a&&a.debug("\xb7\xb7\xb7 Computing B fft"),y.B=await es.fromPolynomial(p.B,4,d,a),a&&a.debug("\xb7\xb7\xb7 Computing C fft"),y.C=await es.fromPolynomial(p.C,4,d,a),p.A.blindCoefficients([S.b[2],S.b[1]]),p.B.blindCoefficients([S.b[4],S.b[3]]),p.C.blindCoefficients([S.b[6],S.b[5]]),p.A.degree()>=u.domainSize+2)throw Error("A Polynomial is not well calculated");if(p.B.degree()>=u.domainSize+2)throw Error("B Polynomial is not well calculated");if(p.C.degree()>=u.domainSize+2)throw Error("C Polynomial is not well calculated")}async function A(){a&&a.debug("> Computing challenges beta and gamma"),x.reset(),x.addPolCommitment(u.Qm),x.addPolCommitment(u.Ql),x.addPolCommitment(u.Qr),x.addPolCommitment(u.Qo),x.addPolCommitment(u.Qc),x.addPolCommitment(u.S1),x.addPolCommitment(u.S2),x.addPolCommitment(u.S3);for(let t=0;t<u.nPublic;t++)x.addScalar(b.A.slice(t*c,t*c+c));x.addPolCommitment(v.getPolynomial("A")),x.addPolCommitment(v.getPolynomial("B")),x.addPolCommitment(v.getPolynomial("C")),S.beta=x.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.beta: "+f.toString(S.beta,16)),x.reset(),x.addScalar(S.beta),S.gamma=x.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.gamma: "+f.toString(S.gamma,16)),a&&a.debug("> Computing Z polynomial"),await z(),a&&a.debug("> Computing Z MSM");let t=await p.Z.multiExponentiation(C,"Z");v.addPolynomial("Z",t)}async function z(){a&&a.debug("\xb7\xb7\xb7 Computing Z evaluations");let t=new n.BigBuffer(w),e=new n.BigBuffer(w);t.set(f.one,0),e.set(f.one,0);let i=f.one;for(let a=0;a<u.domainSize;a++){let n=a*c,r=b.A.slice(n,n+c),o=b.B.slice(n,n+c),l=b.C.slice(n,n+c),s=f.mul(S.beta,i),d=f.add(r,s);d=f.add(d,S.gamma);let w=f.add(o,f.mul(u.k1,s));w=f.add(w,S.gamma);let g=f.add(l,f.mul(u.k2,s));g=f.add(g,S.gamma);let h=f.mul(d,f.mul(w,g)),m=f.add(r,f.mul(y.Sigma1.getEvaluation(4*a),S.beta));m=f.add(m,S.gamma);let p=f.add(o,f.mul(y.Sigma2.getEvaluation(4*a),S.beta));p=f.add(p,S.gamma);let v=f.add(l,f.mul(y.Sigma3.getEvaluation(4*a),S.beta));v=f.add(v,S.gamma);let x=f.mul(m,f.mul(p,v));h=f.mul(t.slice(n,n+c),h),t.set(h,(a+1)%u.domainSize*c),x=f.mul(e.slice(n,n+c),x),e.set(x,(a+1)%u.domainSize*c),i=f.mul(i,f.w[u.power])}e=await f.batchInverse(e);for(let a=0;a<u.domainSize;a++){let i=a*c,n=f.mul(t.slice(i,i+c),e.slice(i,i+c));t.set(n,i)}if(b.Z=t,!f.eq(t.slice(0,c),f.one))throw Error("Copy constraints does not match");if(a&&a.debug("\xb7\xb7\xb7 Computing Z ifft"),p.Z=await el.fromEvaluations(b.Z,d,a),a&&a.debug("\xb7\xb7\xb7 Computing Z fft"),y.Z=await es.fromPolynomial(p.Z,4,d,a),p.Z.blindCoefficients([S.b[9],S.b[8],S.b[7]]),p.Z.degree()>=u.domainSize+3)throw Error("Z Polynomial is not well calculated");delete b.Z}async function P(){a&&a.debug("> Computing challenge alpha"),x.reset(),x.addScalar(S.beta),x.addScalar(S.gamma),x.addPolCommitment(v.getPolynomial("Z")),S.alpha=x.getChallenge(),S.alpha2=f.square(S.alpha),a&&a.debug("\xb7\xb7\xb7 challenges.alpha: "+f.toString(S.alpha,16)),a&&a.debug("> Computing T polynomial"),await R(),a&&a.debug("> Computing T MSM");let t=await p.T1.multiExponentiation(C,"T1"),e=await p.T2.multiExponentiation(C,"T2"),i=await p.T3.multiExponentiation(C,"T3");v.addPolynomial("T1",t),v.addPolynomial("T2",e),v.addPolynomial("T3",i)}async function R(){a&&a.debug(`\xb7\xb7\xb7 Reading sections 8, 9, 7, 10, 11. Q selectors`),y.QL=new es(new n.BigBuffer(4*w),d,a),y.QR=new es(new n.BigBuffer(4*w),d,a),y.QM=new es(new n.BigBuffer(4*w),d,a),y.QO=new es(new n.BigBuffer(4*w),d,a),y.QC=new es(new n.BigBuffer(4*w),d,a),await l.readToBuffer(y.QL.eval,0,4*w,s[8][0].p+w),await l.readToBuffer(y.QR.eval,0,4*w,s[9][0].p+w),await l.readToBuffer(y.QM.eval,0,4*w,s[7][0].p+w),await l.readToBuffer(y.QO.eval,0,4*w,s[10][0].p+w),await l.readToBuffer(y.QC.eval,0,4*w,s[11][0].p+w),y.Lagrange=new es(new n.BigBuffer(4*w*u.nPublic),d,a);for(let t=0;t<u.nPublic;t++)await l.readToBuffer(y.Lagrange.eval,t*w*4,4*w,s[13][0].p+5*t*w+w);b.T=new n.BigBuffer(4*w),b.Tz=new n.BigBuffer(4*w),a&&a.debug("\xb7\xb7\xb7 Computing T evaluations");let t=f.one;for(let e=0;e<4*u.domainSize;e++){a&&0!==e&&e%1e5==0&&a.debug(`      T evaluation ${e}/${4*u.domainSize}`);let i=y.A.getEvaluation(e),n=y.B.getEvaluation(e),r=y.C.getEvaluation(e),o=y.Z.getEvaluation(e),l=y.Z.getEvaluation((4*u.domainSize+4+e)%(4*u.domainSize)),s=y.QM.getEvaluation(e),d=y.QL.getEvaluation(e),w=y.QR.getEvaluation(e),g=y.QO.getEvaluation(e),h=y.QC.getEvaluation(e),m=y.Sigma1.getEvaluation(e),p=y.Sigma2.getEvaluation(e),v=y.Sigma3.getEvaluation(e),x=f.add(S.b[2],f.mul(S.b[1],t)),C=f.add(S.b[4],f.mul(S.b[3],t)),F=f.add(S.b[6],f.mul(S.b[5],t)),E=f.square(t),G=f.add(f.add(f.mul(S.b[7],E),f.mul(S.b[8],t)),S.b[9]),B=f.mul(t,f.w[u.power]),_=f.square(B),T=f.add(f.add(f.mul(S.b[7],_),f.mul(S.b[8],B)),S.b[9]),L=f.zero;for(let t=0;t<u.nPublic;t++){let a=4*t*u.domainSize+e,i=y.Lagrange.getEvaluation(a),n=b.A.slice(t*c,(t+1)*c);L=f.sub(L,f.mul(i,n))}let[A,z]=eo.mul2(i,n,x,C,e%4,f);A=f.mul(A,s),z=f.mul(z,s),A=f.add(A,f.mul(i,d)),z=f.add(z,f.mul(x,d)),A=f.add(A,f.mul(n,w)),z=f.add(z,f.mul(C,w)),A=f.add(A,f.mul(r,g)),z=f.add(z,f.mul(F,g)),A=f.add(A,L),A=f.add(A,h);let P=f.mul(S.beta,t),R=i;R=f.add(R,P),R=f.add(R,S.gamma);let U=n;U=f.add(U,f.mul(P,u.k1)),U=f.add(U,S.gamma);let $=r;$=f.add($,f.mul(P,u.k2)),$=f.add($,S.gamma);let[k,I]=eo.mul4(R,U,$,o,x,C,F,G,e%4,f);k=f.mul(k,S.alpha),I=f.mul(I,S.alpha);let O=i;O=f.add(O,f.mul(S.beta,m)),O=f.add(O,S.gamma);let q=n;q=f.add(q,f.mul(S.beta,p)),q=f.add(q,S.gamma);let W=r;W=f.add(W,f.mul(S.beta,v)),W=f.add(W,S.gamma);let[M,V]=eo.mul4(O,q,W,l,x,C,F,T,e%4,f);M=f.mul(M,S.alpha),V=f.mul(V,S.alpha);let N=f.sub(o,f.one);N=f.mul(N,y.Lagrange.getEvaluation(e)),N=f.mul(N,S.alpha2);let Q=f.mul(G,y.Lagrange.getEvaluation(e));Q=f.mul(Q,S.alpha2);let j=f.add(f.sub(f.add(A,k),M),N),H=f.add(f.sub(f.add(z,I),V),Q);b.T.set(j,e*c),b.Tz.set(H,e*c),t=f.mul(t,f.w[u.power+2])}if(a&&a.debug("\xb7\xb7\xb7 Computing T ifft"),p.T=await el.fromEvaluations(b.T,d,a),a&&a.debug("\xb7\xb7\xb7 Computing T / ZH"),p.T.divZh(u.domainSize,4),a&&a.debug("\xb7\xb7\xb7 Computing Tz ifft"),p.Tz=await el.fromEvaluations(b.Tz,d,a),p.T.add(p.Tz),p.T.degree()>=3*u.domainSize+6)throw Error("T Polynomial is not well calculated");a&&a.debug("\xb7\xb7\xb7 Computing T1, T2, T3 polynomials"),p.T1=new el(new n.BigBuffer((u.domainSize+1)*c),d,a),p.T2=new el(new n.BigBuffer((u.domainSize+1)*c),d,a),p.T3=new el(new n.BigBuffer((u.domainSize+6)*c),d,a),p.T1.coef.set(p.T.coef.slice(0,w),0),p.T2.coef.set(p.T.coef.slice(w,2*w),0),p.T3.coef.set(p.T.coef.slice(2*w,3*w+6*c),0),p.T1.setCoef(u.domainSize,S.b[10]);let e=f.sub(p.T2.getCoef(0),S.b[10]);p.T2.setCoef(0,e),p.T2.setCoef(u.domainSize,S.b[11]);let i=f.sub(p.T3.getCoef(0),S.b[11]);p.T3.setCoef(0,i)}async function U(){a&&a.debug("> Computing challenge xi"),x.reset(),x.addScalar(S.alpha),x.addPolCommitment(v.getPolynomial("T1")),x.addPolCommitment(v.getPolynomial("T2")),x.addPolCommitment(v.getPolynomial("T3")),S.xi=x.getChallenge(),S.xiw=f.mul(S.xi,f.w[u.power]),a&&a.debug("\xb7\xb7\xb7 challenges.xi: "+f.toString(S.xi,16)),v.addEvaluation("eval_a",p.A.evaluate(S.xi)),v.addEvaluation("eval_b",p.B.evaluate(S.xi)),v.addEvaluation("eval_c",p.C.evaluate(S.xi)),v.addEvaluation("eval_s1",p.Sigma1.evaluate(S.xi)),v.addEvaluation("eval_s2",p.Sigma2.evaluate(S.xi)),v.addEvaluation("eval_zw",p.Z.evaluate(S.xiw))}async function $(){a&&a.debug("> Computing challenge v"),x.reset(),x.addScalar(S.xi),x.addScalar(v.getEvaluation("eval_a")),x.addScalar(v.getEvaluation("eval_b")),x.addScalar(v.getEvaluation("eval_c")),x.addScalar(v.getEvaluation("eval_s1")),x.addScalar(v.getEvaluation("eval_s2")),x.addScalar(v.getEvaluation("eval_zw")),S.v=[],S.v[1]=x.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.v: "+f.toString(S.v[1],16));for(let t=2;t<6;t++)S.v[t]=f.mul(S.v[t-1],S.v[1]);a&&a.debug("> Computing linearisation polynomial R(X)"),await k(),a&&a.debug("> Computing opening proof polynomial Wxi(X) polynomial"),p.Wxi=new el(new n.BigBuffer(w+6*c),d,a),p.Wxi.add(p.R),p.Wxi.add(p.A,S.v[1]),p.Wxi.add(p.B,S.v[2]),p.Wxi.add(p.C,S.v[3]),p.Wxi.add(p.Sigma1,S.v[4]),p.Wxi.add(p.Sigma2,S.v[5]),p.Wxi.subScalar(f.mul(S.v[1],v.evaluations.eval_a)),p.Wxi.subScalar(f.mul(S.v[2],v.evaluations.eval_b)),p.Wxi.subScalar(f.mul(S.v[3],v.evaluations.eval_c)),p.Wxi.subScalar(f.mul(S.v[4],v.evaluations.eval_s1)),p.Wxi.subScalar(f.mul(S.v[5],v.evaluations.eval_s2)),p.Wxi.divByZerofier(1,S.xi),a&&a.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),I(),a&&a.debug("> Computing Wxi, Wxiw MSM");let t=await p.Wxi.multiExponentiation(C,"Wxi"),e=await p.Wxiw.multiExponentiation(C,"Wxiw");v.addPolynomial("Wxi",t),v.addPolynomial("Wxiw",e)}async function k(){let t=d.Fr;p.QL=new el(new n.BigBuffer(w),d,a),p.QR=new el(new n.BigBuffer(w),d,a),p.QM=new el(new n.BigBuffer(w),d,a),p.QO=new el(new n.BigBuffer(w),d,a),p.QC=new el(new n.BigBuffer(w),d,a),await l.readToBuffer(p.QL.coef,0,w,s[8][0].p),await l.readToBuffer(p.QR.coef,0,w,s[9][0].p),await l.readToBuffer(p.QM.coef,0,w,s[7][0].p),await l.readToBuffer(p.QO.coef,0,w,s[10][0].p),await l.readToBuffer(p.QC.coef,0,w,s[11][0].p),S.xin=S.xi;for(let e=0;e<u.power;e++)S.xin=t.square(S.xin);S.zh=t.sub(S.xin,t.one);let e=[],i=t.e(u.domainSize),r=t.one;for(let a=1;a<=Math.max(1,u.nPublic);a++)e[a]=t.div(t.mul(r,S.zh),t.mul(i,t.sub(S.xi,r))),r=t.mul(r,t.w[u.power]);let o=t.div(t.sub(S.xin,t.one),t.mul(i,t.sub(S.xi,t.one)));if(a){a.debug("Lagrange Evaluations: ");for(let i=1;i<e.length;i++)a.debug(`L${i}(xi)=`+t.toString(e[i],16))}let f=t.zero;for(let a=0;a<F.length;a++){let i=t.e(F[a]);f=t.sub(f,t.mul(i,e[a+1]))}a&&a.debug("PI: "+t.toString(f,16));let g=t.mul(v.evaluations.eval_a,v.evaluations.eval_b),h=v.evaluations.eval_a,m=t.mul(S.beta,S.xi);h=t.add(h,m),h=t.add(h,S.gamma);let b=v.evaluations.eval_b;b=t.add(b,t.mul(m,u.k1)),b=t.add(b,S.gamma);let y=v.evaluations.eval_c;y=t.add(y,t.mul(m,u.k2)),y=t.add(y,S.gamma);let x=t.mul(t.mul(t.mul(h,b),y),S.alpha),C=v.evaluations.eval_a;C=t.add(C,t.mul(S.beta,v.evaluations.eval_s1)),C=t.add(C,S.gamma);let E=v.evaluations.eval_b;E=t.add(E,t.mul(S.beta,v.evaluations.eval_s2)),E=t.add(E,S.gamma);let G=t.mul(C,E);G=t.mul(G,v.evaluations.eval_zw),G=t.mul(G,S.alpha);let B=t.mul(o,S.alpha2);p.R=new el(new n.BigBuffer((u.domainSize+6)*c),d,a),p.R.add(p.QM,g),p.R.add(p.QL,v.evaluations.eval_a),p.R.add(p.QR,v.evaluations.eval_b),p.R.add(p.QO,v.evaluations.eval_c),p.R.add(p.QC),p.R.add(p.Z,x),p.R.sub(p.Sigma3,t.mul(G,S.beta)),p.R.add(p.Z,B);let _=el.fromPolynomial(p.T3,d,a);_.mulScalar(t.square(S.xin)),_.add(p.T2,S.xin),_.add(p.T1),_.mulScalar(S.zh),p.R.sub(_);let T=t.sub(f,t.mul(G,t.add(v.evaluations.eval_c,S.gamma)));T=t.sub(T,B),a&&a.debug("r0: "+t.toString(T,16)),p.R.addScalar(T)}async function I(){p.Wxiw=el.fromPolynomial(p.Z,d,a),p.Wxiw.subScalar(v.evaluations.eval_zw),p.Wxiw.divByZerofier(1,S.xiw)}}let{unstringifyBigInts:ef}=n.utils;async function ec(t,e,a,i){let n=ef(t),r={type:"mem"};return await td(n,e,r),await ed(a,r,i)}let{unstringifyBigInts:ew}=n.utils;async function eg(t,e,a,i){let n=ew(t);a=ew(a);let r=ew(e),o=await G(n.curve),l=o.Fr,s=o.G1;i&&i.info("PLONK VERIFIER STARTED");let u=function(t,e){let a=t.G1,i=t.Fr,n={};return n.A=a.fromObject(e.A),n.B=a.fromObject(e.B),n.C=a.fromObject(e.C),n.Z=a.fromObject(e.Z),n.T1=a.fromObject(e.T1),n.T2=a.fromObject(e.T2),n.T3=a.fromObject(e.T3),n.eval_a=i.fromObject(e.eval_a),n.eval_b=i.fromObject(e.eval_b),n.eval_c=i.fromObject(e.eval_c),n.eval_zw=i.fromObject(e.eval_zw),n.eval_s1=i.fromObject(e.eval_s1),n.eval_s2=i.fromObject(e.eval_s2),n.Wxi=a.fromObject(e.Wxi),n.Wxiw=a.fromObject(e.Wxiw),n}(o,a);if(n=function(t,e){let a=t.G1,i=t.G2,n=t.Fr,r=e;return r.Qm=a.fromObject(e.Qm),r.Ql=a.fromObject(e.Ql),r.Qr=a.fromObject(e.Qr),r.Qo=a.fromObject(e.Qo),r.Qc=a.fromObject(e.Qc),r.S1=a.fromObject(e.S1),r.S2=a.fromObject(e.S2),r.S3=a.fromObject(e.S3),r.k1=n.fromObject(e.k1),r.k2=n.fromObject(e.k2),r.X_2=i.fromObject(e.X_2),r}(o,n),!function(t,e){let a=t.G1;return!!(a.isValid(e.A)&&a.isValid(e.B)&&a.isValid(e.C)&&a.isValid(e.Z)&&a.isValid(e.T1)&&a.isValid(e.T2)&&a.isValid(e.T3)&&a.isValid(e.Wxi)&&a.isValid(e.Wxiw))}(o,u))return i.error("Proof is not well constructed"),!1;if(r.length!=n.nPublic)return i.error("Invalid number of public inputs"),!1;let d=function(t,e,a,i){let n=t.Fr,r={},o=new er(t);o.addPolCommitment(i.Qm),o.addPolCommitment(i.Ql),o.addPolCommitment(i.Qr),o.addPolCommitment(i.Qo),o.addPolCommitment(i.Qc),o.addPolCommitment(i.S1),o.addPolCommitment(i.S2),o.addPolCommitment(i.S3);for(let t=0;t<a.length;t++)o.addScalar(n.e(a[t]));o.addPolCommitment(e.A),o.addPolCommitment(e.B),o.addPolCommitment(e.C),r.beta=o.getChallenge(),o.reset(),o.addScalar(r.beta),r.gamma=o.getChallenge(),o.reset(),o.addScalar(r.beta),o.addScalar(r.gamma),o.addPolCommitment(e.Z),r.alpha=o.getChallenge(),o.reset(),o.addScalar(r.alpha),o.addPolCommitment(e.T1),o.addPolCommitment(e.T2),o.addPolCommitment(e.T3),r.xi=o.getChallenge(),o.reset(),o.addScalar(r.xi),o.addScalar(e.eval_a),o.addScalar(e.eval_b),o.addScalar(e.eval_c),o.addScalar(e.eval_s1),o.addScalar(e.eval_s2),o.addScalar(e.eval_zw),r.v=[],r.v[1]=o.getChallenge();for(let t=2;t<6;t++)r.v[t]=n.mul(r.v[t-1],r.v[1]);return o.reset(),o.addPolCommitment(e.Wxi),o.addPolCommitment(e.Wxiw),r.u=o.getChallenge(),r}(o,u,r,n);if(i){i.debug("beta: "+l.toString(d.beta,16)),i.debug("gamma: "+l.toString(d.gamma,16)),i.debug("alpha: "+l.toString(d.alpha,16)),i.debug("xi: "+l.toString(d.xi,16));for(let t=1;t<6;t++)i&&i.debug("v: "+l.toString(d.v[t],16));i.debug("u: "+l.toString(d.u,16))}let f=function(t,e,a){let i=t.Fr,n=e.xi,r=1;for(let t=0;t<a.power;t++)n=i.square(n),r*=2;e.xin=n,e.zh=i.sub(n,i.one);let o=[],l=i.e(r),s=i.one;for(let t=1;t<=Math.max(1,a.nPublic);t++)o[t]=i.div(i.mul(s,e.zh),i.mul(l,i.sub(e.xi,s))),s=i.mul(s,i.w[a.power]);return o}(o,d,n);if(i)for(let t=1;t<f.length;t++)i.debug(`L${t}(xi)=`+l.toString(f[t],16));if(r.length!=n.nPublic)return i.error("Number of public signals does not match with vk"),!1;let c=function(t,e,a){let i=t.Fr,n=i.zero;for(let t=0;t<e.length;t++){let r=i.e(e[t]);n=i.sub(n,i.mul(r,a[t+1]))}return n}(o,r,f);i&&i.debug("PI(xi): "+l.toString(c,16));let w=function(t,e,a,i,n){let r=t.Fr,o=r.mul(n,r.square(a.alpha)),l=r.add(e.eval_a,r.mul(a.beta,e.eval_s1));l=r.add(l,a.gamma);let s=r.add(e.eval_b,r.mul(a.beta,e.eval_s2));s=r.add(s,a.gamma);let u=r.add(e.eval_c,a.gamma),d=r.mul(r.mul(l,s),u);d=r.mul(d,e.eval_zw),d=r.mul(d,a.alpha);let f=r.sub(r.sub(i,o),d);return f}(o,u,d,c,f[1]);i&&i.debug("r0: "+l.toString(w,16));let g=function(t,e,a,i,n){let r=t.G1,o=t.Fr,l=r.timesFr(i.Qm,o.mul(e.eval_a,e.eval_b));l=r.add(l,r.timesFr(i.Ql,e.eval_a)),l=r.add(l,r.timesFr(i.Qr,e.eval_b)),l=r.add(l,r.timesFr(i.Qo,e.eval_c)),l=r.add(l,i.Qc);let s=o.mul(a.beta,a.xi),u=o.add(o.add(e.eval_a,s),a.gamma),d=o.add(o.add(e.eval_b,o.mul(s,i.k1)),a.gamma),f=o.add(o.add(e.eval_c,o.mul(s,i.k2)),a.gamma),c=o.mul(o.mul(o.mul(u,d),f),a.alpha),w=o.mul(n,o.square(a.alpha)),g=r.timesFr(e.Z,o.add(o.add(c,w),a.u)),h=o.add(o.add(e.eval_a,o.mul(a.beta,e.eval_s1)),a.gamma),m=o.add(o.add(e.eval_b,o.mul(a.beta,e.eval_s2)),a.gamma),b=o.mul(o.mul(a.alpha,a.beta),e.eval_zw),p=r.timesFr(i.S3,o.mul(o.mul(h,m),b)),y=e.T1,S=r.timesFr(e.T2,a.xin),v=r.timesFr(e.T3,o.square(a.xin)),x=r.add(y,r.add(S,v));x=r.timesFr(x,a.zh);let C=r.sub(r.sub(r.add(l,g),p),x);return C}(o,u,d,n,f[1]);i&&i.debug("D: "+s.toString(s.toAffine(g),16));let h=function(t,e,a,i,n){let r=t.G1,o=r.add(n,r.timesFr(e.A,a.v[1]));return o=r.add(o,r.timesFr(e.B,a.v[2])),o=r.add(o,r.timesFr(e.C,a.v[3])),o=r.add(o,r.timesFr(i.S1,a.v[4])),o=r.add(o,r.timesFr(i.S2,a.v[5]))}(o,u,d,n,g);i&&i.debug("F: "+s.toString(s.toAffine(h),16));let m=function(t,e,a,i){let n=t.G1,r=t.Fr,o=r.add(r.neg(i),r.mul(a.v[1],e.eval_a));o=r.add(o,r.mul(a.v[2],e.eval_b)),o=r.add(o,r.mul(a.v[3],e.eval_c)),o=r.add(o,r.mul(a.v[4],e.eval_s1)),o=r.add(o,r.mul(a.v[5],e.eval_s2)),o=r.add(o,r.mul(a.u,e.eval_zw));let l=n.timesFr(n.one,o);return l}(o,u,d,w);i&&i.debug("E: "+s.toString(s.toAffine(m),16));let b=await eh(o,u,d,n,m,h);return i&&(b?i.info("OK!"):i.warn("Invalid Proof")),b}async function eh(t,e,a,i,n,r){let o=t.G1,l=t.Fr,s=e.Wxi;s=o.add(s,o.timesFr(e.Wxiw,a.u));let u=o.timesFr(e.Wxi,a.xi),d=l.mul(l.mul(a.u,a.xi),l.w[i.power]);u=o.add(u,o.timesFr(e.Wxiw,d)),u=o.add(u,r),u=o.sub(u,n);let f=await t.pairingEq(o.neg(s),i.X_2,u,t.G2.one);return f}let{unstringifyBigInts:em}=n.utils;function eb(t){let e=t.toString(16);for(;e.length<64;)e="0"+e;return`"0x${e}"`}var ep=Object.freeze({__proto__:null,setup:ea,fullProve:ec,prove:ed,verify:eg,exportSolidityCallData:async function(t,e){let a=em(t),i=em(e),n=await G(a.curve);n.G1,n.Fr;let r="";for(let t=0;t<i.length;t++)""!=r&&(r+=","),r+=eb(i[t]);return`[${eb(a.A[0])}, ${eb(a.A[1])},${eb(a.B[0])},${eb(a.B[1])},${eb(a.C[0])},${eb(a.C[1])},${eb(a.Z[0])},${eb(a.Z[1])},${eb(a.T1[0])},${eb(a.T1[1])},${eb(a.T2[0])},${eb(a.T2[1])},${eb(a.T3[0])},${eb(a.T3[1])},${eb(a.Wxi[0])},${eb(a.Wxi[1])},${eb(a.Wxiw[0])},${eb(a.Wxiw[1])},${eb(a.eval_a)},${eb(a.eval_b)},${eb(a.eval_c)},${eb(a.eval_s1)},${eb(a.eval_s2)},${eb(a.eval_zw)}][${r}]`}});function ey(t,e){return[t,0,0,e.one,e.zero,e.zero,e.zero,e.zero]}function eS(t,e,a,i,n,r,o,l){return[t,e,a,i,n,r,o,l]}function ev(t,e,a,i,n,r,o,l,s){return[t,e,a,i,n,r,o,l]}class ex{constructor(t,e,a,i,n){this.Fr=t,this.logger=n,this.fnGetAdditionConstraint=a,this.fnGetMultiplicationConstraint=i}processR1csConstraint(t,e,a,i){this.normalizeLinearCombination(e),this.normalizeLinearCombination(a),this.normalizeLinearCombination(i);let n=this.getLinearCombinationType(e),r=this.getLinearCombinationType(a);if(0===n||0===r)return this.processR1csAdditionConstraint(t,i);if(1===n){let n=this.joinLinearCombinations(a,i,e[0]);return this.processR1csAdditionConstraint(t,n)}if(1!==r)return this.processR1csMultiplicationConstraint(t,e,a,i);{let n=this.joinLinearCombinations(e,i,a[0]);return this.processR1csAdditionConstraint(t,n)}}getLinearCombinationType(t){let e=this.Fr.zero,a=0,i=Object.keys(t);for(let n=0;n<i.length;n++)0n==t[i[n]]?delete t[i[n]]:0==i[n]?e=this.Fr.add(e,t[i[n]]):a++;return a>0?2:this.Fr.isZero(e)?0:1}normalizeLinearCombination(t){let e=Object.keys(t);for(let a=0;a<e.length;a++)this.Fr.isZero(t[e[a]])&&delete t[e[a]];return t}joinLinearCombinations(t,e,a){let i={};for(let e in t)void 0===i[e]?i[e]=this.Fr.mul(a,t[e]):i[e]=this.Fr.add(i[e],this.Fr.mul(a,t[e]));for(let t in e)void 0===i[t]?i[t]=e[t]:i[t]=this.Fr.add(i[t],e[t]);return this.normalizeLinearCombination(i)}reduceCoefs(t,e,a,i,n){let r={k:this.Fr.zero,signals:[],coefs:[]},o=[];for(let t in i)0==t?r.k=this.Fr.add(r.k,i[t]):0n!=i[t]&&o.push([Number(t),i[t]]);for(;o.length>n;){let i=o.shift(),n=o.shift(),r=t.nVars++,l=this.fnGetAdditionConstraint(i[0],n[0],r,this.Fr.neg(i[1]),this.Fr.neg(n[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);e.push(l),a.push([i[0],n[0],i[1],n[1]]),o.push([r,this.Fr.one])}for(let t=0;t<o.length;t++)r.signals[t]=o[t][0],r.coefs[t]=o[t][1];for(;r.coefs.length<n;)r.signals.push(0),r.coefs.push(this.Fr.zero);return r}processR1csAdditionConstraint(t,e){let a=[],i=[],n=this.reduceCoefs(t,a,i,e,3),r=this.fnGetAdditionConstraint(n.signals[0],n.signals[1],n.signals[2],n.coefs[0],n.coefs[1],this.Fr.zero,n.coefs[2],n.k);return a.push(r),[a,i]}processR1csMultiplicationConstraint(t,e,a,i){let n=[],r=[],o=this.reduceCoefs(t,n,r,e,1),l=this.reduceCoefs(t,n,r,a,1),s=this.reduceCoefs(t,n,r,i,1),u=this.fnGetMultiplicationConstraint(o.signals[0],l.signals[0],s.signals[0],this.Fr.mul(o.coefs[0],l.k),this.Fr.mul(o.k,l.coefs[0]),this.Fr.mul(o.coefs[0],l.coefs[0]),this.Fr.neg(s.coefs[0]),this.Fr.sub(this.Fr.mul(o.k,l.k),s.k));return n.push(u),[n,r]}}class eC{constructor(t,e,a){this.n=t,this.polynomials=Array(t).fill(void 0),this.curve=e,this.Fr=e.Fr,this.G1=e.G1,this.logger=a}addPolynomial(t,e){if(t>this.n-1)throw Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[t]=e}degree(){return Math.max(...this.polynomials.map((t,e)=>void 0===t?0:t.degree()*this.n+e))}getPolynomial(){let t=this.polynomials.map(t=>void 0===t?0:t.degree()),e=this.degree(),a=2**(B(e-1)+1),i=this.Fr.n8,r=new el(new n.BigBuffer(a*i),this.curve,this.logger);for(let a=0;a<e;a++){let e=a*i,n=e*this.n;for(let o=0;o<this.n;o++)void 0!==this.polynomials[o]&&a<=t[o]&&r.coef.set(this.polynomials[o].coef.slice(e,e+i),n+o*i)}return r}async multiExponentiation(t,e){let a=this.getPolynomial(),i=a.coef.byteLength/this.Fr.n8,n=t.slice(0,i*this.G1.F.n8*2),r=await this.Fr.batchFromMontgomery(a.coef),o=await this.G1.multiExpAffine(n,r,this.logger,e);return this.G1.toAffine(o)}}async function eF(t,e,a,r){let o,l,s;r&&r.info("FFLONK SETUP STARTED"),globalThis.gc&&globalThis.gc(),r&&r.info("> Reading PTau file");let{fd:d,sections:f}=await i.readBinFile(e,"ptau",1,4194304,16777216);if(!f[12])throw Error("Powers of Tau is not well prepared. Section 12 missing.");r&&r.info("> Getting curve from PTau settings");let{curve:c}=await tC(d,f);r&&r.info("> Reading r1cs file");let{fd:w,sections:h}=await i.readBinFile(t,"r1cs",1,4194304,16777216),m=await u.readR1csFd(w,h,{loadConstraints:!1,loadCustomGates:!0});if(m.prime!==c.r)throw Error("r1cs curve does not match powers of tau ceremony curve");let b=c.Fr,p=c.Fr.n8,y=2*c.G1.F.n8,S=2*c.G2.F.n8,v={},x={},C={nVars:m.nVars,nPublic:m.nOutputs+m.nPubInputs},F=new tj,E=new tj;if(r&&r.info("> Processing FFlonk constraints"),await P(c.Fr,m,r),globalThis.gc&&globalThis.gc(),C.cirPower=Math.max(3,B(F.length+2-1)+1),C.domainSize=2**C.cirPower,f[2][0].size<(9*C.domainSize+18)*y)throw Error("Powers of Tau is not big enough for this circuit size. Section 2 too small.");if(f[3][0].size<S)throw Error("Powers of Tau is not well prepared. Section 3 too small.");r&&(r.info("----------------------------"),r.info("  FFLONK SETUP SETTINGS"),r.info(`  Curve:         ${c.name}`),r.info(`  Circuit power: ${C.cirPower}`),r.info(`  Domain size:   ${C.domainSize}`),r.info(`  Vars:          ${C.nVars}`),r.info(`  Public vars:   ${C.nPublic}`),r.info(`  Constraints:   ${F.length}`),r.info(`  Additions:     ${E.length}`),r.info("----------------------------")),r&&r.info("> computing k1 and k2");let[G,_]=function(){let t=b.two;for(;a(t,[],C.cirPower);)b.add(t,b.one);let e=b.add(t,b.one);for(;a(e,[t],C.cirPower);)b.add(e,b.one);return[t,e];function a(t,e,a){let i=2**a,n=b.one;for(let r=0;r<i;r++){if(b.eq(t,n))return!0;for(let a=0;a<e.length;a++)if(b.eq(t,b.mul(e[a],n)))return!0;n=b.mul(n,b.w[a])}return!1}}();r&&r.info("> computing w3");let T=(l=b.e(31624),s=n.Scalar.div(0x810b7bdd032f006f40d60f3c0403964dc08a6b6bef43d6d8b505398a8000000n,n.Scalar.e(3)),b.exp(l,s));r&&r.info("> computing w4");let L=b.w[2];r&&r.info("> computing w8");let A=b.w[3];r&&r.info("> computing wr");let z=function(t,e){let a=e.e(0x108c3d36f14c2facdf4d615f022a01cfcf001cc24e3db9d89373caf21d767f0n);return e.exp(a,2**(28-t))}(C.cirPower,c.Fr);return await R(),await w.close(),await d.close(),r&&r.info("FFLONK SETUP FINISHED"),0;async function P(t,e,a){for(let e=0;e<C.nPublic;e++)F.push(ey(e+1,t));let i=new ex(t,ey,eS,ev,a),n=await g.readSection(w,h,2),r=0;for(let t=0;t<e.nConstraints;t++){a&&0!==t&&t%5e5==0&&a.info(`    processing r1cs constraints ${t}/${e.nConstraints}`);let[n,r]=i.processR1csConstraint(C,...function(){let t=[];return t[0]=o(),t[1]=o(),t[2]=o(),t}());F.push(...n),E.push(...r)}function o(){let t={},a=n.slice(r,r+4);r+=4;let i=new DataView(a.buffer),o=i.getUint32(0,!0),l=n.slice(r,r+(4+e.n8)*o);r+=(4+e.n8)*o;let s=new DataView(l.buffer);for(let a=0;a<o;a++){let i=s.getUint32(a*(4+e.n8),!0),n=e.F.fromRprLE(l,a*(4+e.n8)+4);t[i]=n}return t}return 0}async function R(){r&&r.info("> Writing the zkey file");let t=await i.createBinFile(a,"zkey",1,17,4194304,16777216);r&&r.info(`\xb7\xb7\xb7 Writing Section 1. Zkey Header`),await U(t),r&&r.info(`\xb7\xb7\xb7 Writing Section 3. Additions`),await $(t),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 4. A Map`),await k(t,4,0,"A map"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 5. B Map`),await k(t,5,1,"B map"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 6. C Map`),await k(t,6,2,"C map"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 7. QL`),await I(t,7,3,"QL"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 8. QR`),await I(t,8,4,"QR"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 9. QM`),await I(t,9,5,"QM"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 10. QO`),await I(t,10,6,"QO"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 11. QC`),await I(t,11,7,"QC"),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Sections 12,13,14. Sigma1, Sigma2 & Sigma 3`),await O(t),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 15. Lagrange Polynomials`),await q(t),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 16. Powers of Tau`),await W(t),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 17. C0`),await M(t),globalThis.gc&&globalThis.gc(),r&&r.info(`\xb7\xb7\xb7 Writing Section 2. FFlonk Header`),await V(t),globalThis.gc&&globalThis.gc(),r&&r.info("> Writing the zkey file finished"),await t.close()}async function U(t){await i.startWriteSection(t,1),await t.writeULE32(10),await i.endWriteSection(t)}async function $(t){await i.startWriteSection(t,3);let e=new Uint8Array(8+2*p),a=new DataView(e.buffer);for(let i=0;i<E.length;i++){r&&0!==i&&i%5e5==0&&r.info(`      writing Additions: ${i}/${E.length}`);let n=E[i];a.setUint32(0,n[0],!0),a.setUint32(4,n[1],!0),e.set(n[2],8),e.set(n[3],8+p),await t.write(e)}await i.endWriteSection(t)}async function k(t,e,a,n){await i.startWriteSection(t,e);for(let e=0;e<F.length;e++)r&&0!==e&&e%5e5==0&&r.info(`      writing witness ${n}: ${e}/${F.length}`),await t.writeULE32(F[e][a]);await i.endWriteSection(t)}async function I(t,e,a,o){let l=new n.BigBuffer(C.domainSize*p);for(let t=0;t<F.length;t++)l.set(F[t][a],t*p),r&&0!==t&&t%5e5==0&&r.info(`      writing ${o}: ${t}/${F.length}`);v[o]=await el.fromEvaluations(l,c,r),x[o]=await es.fromPolynomial(v[o],4,c,r),await i.startWriteSection(t,e),await t.write(v[o].coef),await t.write(x[o].eval),await i.endWriteSection(t)}async function O(t){let e=new n.BigBuffer(p*C.domainSize*3),a=new tj(C.nVars),o=new tj(C.nVars),l=b.one;for(let t=0;t<C.domainSize;t++)t<F.length?(s(F[t][0],t),s(F[t][1],C.domainSize+t),s(F[t][2],2*C.domainSize+t)):t<C.domainSize-2?(s(0,t),s(0,C.domainSize+t),s(0,2*C.domainSize+t)):(e.set(l,t*p),e.set(b.mul(l,G),(C.domainSize+t)*p),e.set(b.mul(l,_),(2*C.domainSize+t)*p)),l=b.mul(l,b.w[C.cirPower]),r&&0!==t&&t%5e5==0&&r.info(`      writing sigma phase1: ${t}/${F.length}`);for(let t=0;t<C.nVars;t++)void 0!==o[t]?e.set(a[t],o[t]*p):console.log("Variable not used"),r&&0!==t&&t%5e5==0&&r.info(`      writing sigma phase2: ${t}/${C.nVars}`);globalThis.gc&&globalThis.gc();for(let a=0;a<3;a++){let n=0===a?12:1===a?13:14,o="S"+(a+1);v[o]=await el.fromEvaluations(e.slice(C.domainSize*p*a,C.domainSize*p*(a+1)),c,r),x[o]=await es.fromPolynomial(v[o],4,c,r),await i.startWriteSection(t,n),await t.write(v[o].coef),await t.write(x[o].eval),await i.endWriteSection(t),globalThis.gc&&globalThis.gc()}return 0;function s(t,i){let n;void 0===a[t]?o[t]=i:e.set(a[t],i*p),n=i<C.domainSize?l:i<2*C.domainSize?b.mul(l,G):b.mul(l,_),a[t]=n}}async function q(t){await i.startWriteSection(t,15);let e=Math.max(C.nPublic,1);for(let a=0;a<e;a++){let e=new n.BigBuffer(C.domainSize*p);e.set(b.one,a*p),await N(t,e)}await i.endWriteSection(t)}async function W(t){await i.startWriteSection(t,16),o=new n.BigBuffer((9*C.domainSize+18)*y),await d.readToBuffer(o,0,(9*C.domainSize+18)*y,f[2][0].p),await t.write(o),await i.endWriteSection(t)}async function M(t){let e=new eC(8,c,r);if(e.addPolynomial(0,v.QL),e.addPolynomial(1,v.QR),e.addPolynomial(2,v.QO),e.addPolynomial(3,v.QM),e.addPolynomial(4,v.QC),e.addPolynomial(5,v.S1),e.addPolynomial(6,v.S2),e.addPolynomial(7,v.S3),v.C0=e.getPolynomial(),v.C0.degree()>=8*C.domainSize)throw Error("C0 Polynomial is not well calculated");await i.startWriteSection(t,17),await t.write(v.C0.coef),await i.endWriteSection(t)}async function V(t){let e;await i.startWriteSection(t,2);let a=c.q,r=(Math.floor((n.Scalar.bitLength(a)-1)/64)+1)*8;await t.writeULE32(r),await i.writeBigInt(t,a,r);let l=c.r,s=(Math.floor((n.Scalar.bitLength(l)-1)/64)+1)*8;await t.writeULE32(s),await i.writeBigInt(t,l,s),await t.writeULE32(C.nVars),await t.writeULE32(C.nPublic),await t.writeULE32(C.domainSize),await t.writeULE32(E.length),await t.writeULE32(F.length),await t.write(G),await t.write(_),await t.write(T),await t.write(L),await t.write(A),await t.write(z),e=await d.read(S,f[3][0].p+S),await t.write(e);let u=await v.C0.multiExponentiation(o,"C0");await t.write(u),await i.endWriteSection(t)}async function N(t,e){let[a,i]=await el.to4T(e,C.domainSize,[],b);return await t.write(a),await t.write(i),[a,i]}}let{stringifyBigInts:eE}=n.utils;async function eG(t,e,a){a&&a.info("FFLONK PROVER STARTED"),a&&a.info("> Reading witness file");let{fd:i,sections:r}=await g.readBinFile(e,"wtns",2,33554432,8388608),o=await ti(i,r);a&&a.info("> Reading zkey file");let{fd:l,sections:s}=await g.readBinFile(t,"zkey",2,33554432,8388608),u=await N(l,s);if(10!==u.protocolId)throw Error("zkey file is not fflonk");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!==u.nVars-u.nAdditions)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}, ${u.nAdditions}`);let d=u.curve,f=d.Fr,c=d.Fr.n8,w=2*d.G1.F.n8,h=u.domainSize*c;a&&(a.info("----------------------------"),a.info("  FFLONK PROVE SETTINGS"),a.info(`  Curve:         ${d.name}`),a.info(`  Circuit power: ${u.power}`),a.info(`  Domain size:   ${u.domainSize}`),a.info(`  Vars:          ${u.nVars}`),a.info(`  Public vars:   ${u.nPublic}`),a.info(`  Constraints:   ${u.nConstraints}`),a.info(`  Additions:     ${u.nAdditions}`),a.info("----------------------------")),a&&a.info("> Reading witness file data");let m=await g.readSection(i,r,2);await i.close(),m.set(f.zero,0);let b=new n.BigBuffer(u.nAdditions*c),p={},y={},S={},v={},x={},C={},F=new ei(d,a);a&&a.info("> Reading Section 3. Additions"),await _(),a&&a.info("> Reading Sections 12,13,14. Sigma1, Sigma2 & Sigma 3"),a&&a.info("\xb7\xb7\xb7 Reading Sigma polynomials "),y.Sigma1=new el(new n.BigBuffer(h),d,a),y.Sigma2=new el(new n.BigBuffer(h),d,a),y.Sigma3=new el(new n.BigBuffer(h),d,a),await l.readToBuffer(y.Sigma1.coef,0,h,s[12][0].p),await l.readToBuffer(y.Sigma2.coef,0,h,s[13][0].p),await l.readToBuffer(y.Sigma3.coef,0,h,s[14][0].p),a&&a.info("\xb7\xb7\xb7 Reading Sigma evaluations"),S.Sigma1=new es(new n.BigBuffer(4*h),d,a),S.Sigma2=new es(new n.BigBuffer(4*h),d,a),S.Sigma3=new es(new n.BigBuffer(4*h),d,a),await l.readToBuffer(S.Sigma1.eval,0,4*h,s[12][0].p+h),await l.readToBuffer(S.Sigma2.eval,0,4*h,s[13][0].p+h),await l.readToBuffer(S.Sigma3.eval,0,4*h,s[14][0].p+h),a&&a.info("> Reading Section 16. Powers of Tau");let E=new n.BigBuffer(16*u.domainSize*w);await l.readToBuffer(E,0,(9*u.domainSize+18)*w,s[16][0].p),globalThis.gc&&globalThis.gc(),a&&a.info(""),a&&a.info("> ROUND 1"),await A(),delete y.T0,delete S.QL,delete S.QR,delete S.QM,delete S.QO,delete S.QC,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 2"),await z(),delete p.A,delete p.B,delete p.C,delete S.A,delete S.B,delete S.C,delete S.Sigma1,delete S.Sigma2,delete S.Sigma3,delete S.lagrange1,delete S.Z,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 3"),await P(),delete y.A,delete y.B,delete y.C,delete y.Z,delete y.T1,delete y.T2,delete y.Sigma1,delete y.Sigma2,delete y.Sigma3,delete y.QL,delete y.QR,delete y.QM,delete y.QC,delete y.QO,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 4"),await R(),globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 5"),await U(),delete y.C0,delete y.C1,delete y.C2,delete y.R1,delete y.R2,delete y.F,delete y.L,delete y.ZT,delete y.ZTS2,await l.close(),globalThis.gc&&globalThis.gc(),F.addEvaluation("inv",function(){let t=x.xi;for(let e=0;e<u.power;e++)t=f.square(t);v.zh=f.sub(t,f.one),function(t,e,a,i){let n=i.Fr,r=e.length,o=n.mul(n.e(r),n.exp(e[0],r-2));for(let i=0;i<r;i++){let l=e[(r-1)*i%r],s=n.sub(a,e[i]);t[["LiS0_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(v,C.S0.h0w8,x.y,d),function(t,e,a,i){let n=i.Fr,r=e.length,o=n.mul(n.e(r),n.exp(e[0],r-2));for(let i=0;i<r;i++){let l=e[(r-1)*i%r],s=n.sub(a,e[i]);t[["LiS1_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(v,C.S1.h1w4,x.y,d),function(t,e,a,i,n,r,o){let l=o.Fr,s=l.mul(l.e(3),e[0]),u=l.sub(n,r),d=l.mul(s,u);for(let a=0;a<3;a++){let n=e[2*a%3],r=l.sub(i,e[a]);t[["LiS2_"+(a+1)]]=l.mul(d,l.mul(n,r))}let f=l.mul(l.e(3),a[0]),c=l.sub(r,n);d=l.mul(f,c);for(let e=0;e<3;e++){let n=a[2*e%3],r=l.sub(i,a[e]);t[["LiS2_"+(e+1+3)]]=l.mul(d,l.mul(n,r))}}(v,C.S2.h2w3,C.S2.h3w3,x.y,x.xi,x.xiw,d);let e=Math.max(1,u.nPublic),a=f.one;for(let t=0;t<e;t++)v["Li_"+(t+1)]=f.mul(f.e(u.domainSize),f.sub(x.xi,a)),a=f.mul(a,f.w[u.power]);let i=f.one;for(let t of Object.values(v))if(Array.isArray(t))for(let e of t)i=f.mul(i,e);else i=f.mul(i,t);return f.inv(i)}());let G=F.toObjectProof();G.protocol="fflonk",G.curve=d.name;let B=[];for(let t=1;t<=u.nPublic;t++){let e=t*c,a=m.slice(e,e+c);B.push(n.Scalar.fromRprLE(a))}return a&&a.info("FFLONK PROVER FINISHED"),{proof:eE(G),publicSignals:eE(B)};async function _(){a&&a.info("\xb7\xb7\xb7 Computing additions");let t=await g.readSection(l,s,3),e=8+2*c;for(let i=0;i<u.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.info(`    addition ${i}/${u.nAdditions}`);let n=i*e,r=T(t,n);n+=4;let o=T(t,n);n+=4;let l=t.slice(n,n+c);n+=c;let s=t.slice(n,n+c),d=L(r),w=L(o),g=f.add(f.mul(l,d),f.mul(s,w));b.set(g,c*i)}}function T(t,e){let a=t.slice(e,e+4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);return i.getUint32(0,!0)}function L(t){let e=u.nVars-u.nAdditions;if(t<e)return m.slice(t*c,t*c+c);if(t<u.nVars){let a=(t-e)*c;return b.slice(a,a+c)}return f.zero}async function A(){x.b=[];for(let t=1;t<=9;t++)x.b[t]=f.random();a&&a.info("> Computing A, B, C wire polynomials"),await e(),a&&a.info("> Computing T0 polynomial"),await i(),a&&a.info("> Computing C1 polynomial"),await r(),a&&a.info("> Computing C1 multi exponentiation");let t=await y.C1.multiExponentiation(E,"C1");return F.addPolynomial("C1",t),0;async function e(){a&&a.info("\xb7\xb7\xb7 Reading data from zkey file"),p.A=new n.BigBuffer(h),p.B=new n.BigBuffer(h),p.C=new n.BigBuffer(h);let t=await g.readSection(l,s,4),e=await g.readSection(l,s,5),i=await g.readSection(l,s,6);for(let a=0;a<u.nConstraints;a++){let n=a*c,r=4*a,o=T(t,r);p.A.set(L(o),n);let l=T(e,r);p.B.set(L(l),n);let s=T(i,r);p.C.set(L(s),n)}if(p.A.set(x.b[1],h-64),p.A.set(x.b[2],h-32),p.B.set(x.b[3],h-64),p.B.set(x.b[4],h-32),p.C.set(x.b[5],h-64),p.C.set(x.b[6],h-32),p.A=await f.batchToMontgomery(p.A),p.B=await f.batchToMontgomery(p.B),p.C=await f.batchToMontgomery(p.C),a&&a.info("\xb7\xb7\xb7 Computing A ifft"),y.A=await el.fromEvaluations(p.A,d,a),a&&a.info("\xb7\xb7\xb7 Computing B ifft"),y.B=await el.fromEvaluations(p.B,d,a),a&&a.info("\xb7\xb7\xb7 Computing C ifft"),y.C=await el.fromEvaluations(p.C,d,a),a&&a.info("\xb7\xb7\xb7 Computing A fft"),S.A=await es.fromPolynomial(y.A,4,d,a),a&&a.info("\xb7\xb7\xb7 Computing B fft"),S.B=await es.fromPolynomial(y.B,4,d,a),a&&a.info("\xb7\xb7\xb7 Computing C fft"),S.C=await es.fromPolynomial(y.C,4,d,a),y.A.degree()>=u.domainSize)throw Error("A Polynomial is not well calculated");if(y.B.degree()>=u.domainSize)throw Error("B Polynomial is not well calculated");if(y.C.degree()>=u.domainSize)throw Error("C Polynomial is not well calculated")}async function i(){a&&a.info(`\xb7\xb7\xb7 Reading sections 7, 8, 9, 10, 11. Q selectors`),S.QL=new es(new n.BigBuffer(4*h),d,a),S.QR=new es(new n.BigBuffer(4*h),d,a),S.QM=new es(new n.BigBuffer(4*h),d,a),S.QO=new es(new n.BigBuffer(4*h),d,a),S.QC=new es(new n.BigBuffer(4*h),d,a),await l.readToBuffer(S.QL.eval,0,4*h,s[7][0].p+h),await l.readToBuffer(S.QR.eval,0,4*h,s[8][0].p+h),await l.readToBuffer(S.QM.eval,0,4*h,s[9][0].p+h),await l.readToBuffer(S.QO.eval,0,4*h,s[10][0].p+h),await l.readToBuffer(S.QC.eval,0,4*h,s[11][0].p+h);let t=await g.readSection(l,s,15);S.lagrange1=new es(t,d,a),p.T0=new n.BigBuffer(4*h),a&&a.info("\xb7\xb7\xb7 Computing T0 evaluations");for(let t=0;t<4*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.info(`      T0 evaluation ${t}/${4*u.domainSize}`);let e=S.A.getEvaluation(t),i=S.B.getEvaluation(t),n=S.C.getEvaluation(t),r=S.QL.getEvaluation(t),o=S.QR.getEvaluation(t),l=S.QM.getEvaluation(t),s=S.QO.getEvaluation(t),d=S.QC.getEvaluation(t),w=f.zero;for(let e=0;e<u.nPublic;e++){let a=5*e*u.domainSize+u.domainSize+t,i=S.lagrange1.getEvaluation(a),n=p.A.slice(e*c,(e+1)*c);w=f.sub(w,f.mul(i,n))}let g=f.mul(e,r),h=f.mul(i,o),m=f.mul(f.mul(e,i),l),b=f.mul(n,s),y=f.add(g,f.add(h,f.add(m,f.add(b,f.add(d,w)))));p.T0.set(y,t*c)}if(a&&a.info("buffer T0: "+p.T0.byteLength/c),a&&a.info("\xb7\xb7\xb7 Computing T0 ifft"),y.T0=await el.fromEvaluations(p.T0,d,a),a&&a.info("T0 length: "+y.T0.length()),a&&a.info("T0 degree: "+y.T0.degree()),a&&a.info("\xb7\xb7\xb7 Computing T0 / ZH"),y.T0.divByZerofier(u.domainSize,f.one),y.T0.degree()>=2*u.domainSize-2)throw Error(`T0 Polynomial is not well calculated (degree is ${y.T0.degree()} and must be less than ${2*u.domainSize+2}`);delete p.T0}async function r(){let t=new eC(4,d,a);if(t.addPolynomial(0,y.A),t.addPolynomial(1,y.B),t.addPolynomial(2,y.C),t.addPolynomial(3,y.T0),y.C1=t.getPolynomial(),y.C1.degree()>=8*u.domainSize-8)throw Error("C1 Polynomial is not well calculated")}}async function z(){a&&a.info("> Computing challenges beta and gamma");let t=new er(d);t.addPolCommitment(u.C0);for(let e=0;e<u.nPublic;e++)t.addScalar(p.A.slice(e*c,e*c+c));t.addPolCommitment(F.getPolynomial("C1")),x.beta=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.beta: "+f.toString(x.beta)),t.reset(),t.addScalar(x.beta),x.gamma=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.gamma: "+f.toString(x.gamma)),a&&a.info("> Computing Z polynomial"),await i(),a&&a.info("> Computing T1 polynomial"),await r(),a&&a.info("> Computing T2 polynomial"),await o(),a&&a.info("> Computing C2 polynomial"),await l(),a&&a.info("> Computing C2 multi exponentiation");let e=await y.C2.multiExponentiation(E,"C2");return F.addPolynomial("C2",e),0;async function i(){a&&a.info("\xb7\xb7\xb7 Computing Z evaluations");let t=new n.BigBuffer(h),e=new n.BigBuffer(h);t.set(f.one,0),e.set(f.one,0);let i=f.one;for(let n=0;n<u.domainSize;n++){a&&0!==n&&n%1e5==0&&a.info(`    Z evaluation ${n}/${u.domainSize}`);let r=n*c,o=f.mul(x.beta,i),l=p.A.slice(r,r+c);l=f.add(l,o),l=f.add(l,x.gamma);let s=p.B.slice(r,r+c);s=f.add(s,f.mul(u.k1,o)),s=f.add(s,x.gamma);let d=p.C.slice(r,r+c);d=f.add(d,f.mul(u.k2,o)),d=f.add(d,x.gamma);let w=f.mul(l,f.mul(s,d)),g=p.A.slice(r,r+c);g=f.add(g,f.mul(x.beta,S.Sigma1.getEvaluation(4*n))),g=f.add(g,x.gamma);let h=p.B.slice(r,r+c);h=f.add(h,f.mul(x.beta,S.Sigma2.getEvaluation(4*n))),h=f.add(h,x.gamma);let m=p.C.slice(r,r+c);m=f.add(m,f.mul(x.beta,S.Sigma3.getEvaluation(4*n))),m=f.add(m,x.gamma);let b=f.mul(g,f.mul(h,m));w=f.mul(t.slice(r,r+c),w),t.set(w,(n+1)%u.domainSize*c),b=f.mul(e.slice(r,r+c),b),e.set(b,(n+1)%u.domainSize*c),i=f.mul(i,f.w[u.power])}e=await f.batchInverse(e);for(let a=0;a<u.domainSize;a++){let i=a*c,n=f.mul(t.slice(i,i+c),e.slice(i,i+c));t.set(n,i)}if(p.Z=t,!f.eq(t.slice(0,c),f.one))throw Error("Copy constraints does not match");if(a&&a.info("\xb7\xb7\xb7 Computing Z ifft"),y.Z=await el.fromEvaluations(p.Z,d,a),a&&a.info("\xb7\xb7\xb7 Computing Z fft"),S.Z=await es.fromPolynomial(y.Z,4,d,a),y.Z.blindCoefficients([x.b[9],x.b[8],x.b[7]]),y.Z.degree()>=u.domainSize+3)throw Error("Z Polynomial is not well calculated");delete p.Z}async function r(){a&&a.info("\xb7\xb7\xb7 Computing T1 evaluations"),p.T1=new n.BigBuffer(2*h),p.T1z=new n.BigBuffer(2*h);let t=f.one;for(let e=0;e<2*u.domainSize;e++){a&&0!==e&&e%1e5==0&&a.info(`    T1 evaluation ${e}/${4*u.domainSize}`);let i=f.square(t),n=S.Z.getEvaluation(2*e),r=f.add(f.add(f.mul(x.b[7],i),f.mul(x.b[8],t)),x.b[9]),o=S.lagrange1.getEvaluation(u.domainSize+2*e),l=f.mul(f.sub(n,f.one),o),s=f.mul(r,o);p.T1.set(l,e*c),p.T1z.set(s,e*c),t=f.mul(t,f.w[u.power+1])}if(a&&a.info("\xb7\xb7\xb7 Computing T1 ifft"),y.T1=await el.fromEvaluations(p.T1,d,a),y.T1.divByZerofier(u.domainSize,f.one),a&&a.info("\xb7\xb7\xb7 Computing T1z ifft"),y.T1z=await el.fromEvaluations(p.T1z,d,a),y.T1.add(y.T1z),y.T1.degree()>=u.domainSize+2)throw Error("T1 Polynomial is not well calculated");delete p.T1,delete p.T1z,delete y.T1z}async function o(){a&&a.info("\xb7\xb7\xb7 Computing T2 evaluations"),p.T2=new n.BigBuffer(4*h),p.T2z=new n.BigBuffer(4*h);let t=f.one;for(let e=0;e<4*u.domainSize;e++){a&&0!==e&&e%1e5==0&&a.info(`    T2 evaluation ${e}/${4*u.domainSize}`);let i=f.square(t),n=f.mul(t,f.w[u.power]),r=f.square(n),o=S.A.getEvaluation(e),l=S.B.getEvaluation(e),s=S.C.getEvaluation(e),d=S.Z.getEvaluation(e),w=S.Z.getEvaluation((4*u.domainSize+4+e)%(4*u.domainSize)),g=f.add(f.add(f.mul(x.b[7],i),f.mul(x.b[8],t)),x.b[9]),h=f.add(f.add(f.mul(x.b[7],r),f.mul(x.b[8],n)),x.b[9]),m=S.Sigma1.getEvaluation(e),b=S.Sigma2.getEvaluation(e),y=S.Sigma3.getEvaluation(e),v=f.mul(x.beta,t),C=f.add(o,v);C=f.add(C,x.gamma);let F=f.add(l,f.mul(v,u.k1));F=f.add(F,x.gamma);let E=f.add(s,f.mul(v,u.k2));E=f.add(E,x.gamma);let G=f.mul(f.mul(f.mul(C,F),E),d),B=f.mul(f.mul(f.mul(C,F),E),g),_=f.add(o,f.mul(x.beta,m));_=f.add(_,x.gamma);let T=f.add(l,f.mul(x.beta,b));T=f.add(T,x.gamma);let L=f.add(s,f.mul(x.beta,y));L=f.add(L,x.gamma);let A=f.mul(f.mul(f.mul(_,T),L),w),z=f.mul(f.mul(f.mul(_,T),L),h),P=f.sub(G,A),R=f.sub(B,z);p.T2.set(P,e*c),p.T2z.set(R,e*c),t=f.mul(t,f.w[u.power+2])}if(a&&a.info("\xb7\xb7\xb7 Computing T2 ifft"),y.T2=await el.fromEvaluations(p.T2,d,a),a&&a.info("\xb7\xb7\xb7 Computing T2 / ZH"),y.T2.divByZerofier(u.domainSize,f.one),a&&a.info("\xb7\xb7\xb7 Computing T2z ifft"),y.T2z=await el.fromEvaluations(p.T2z,d,a),y.T2.add(y.T2z),y.T2.degree()>=3*u.domainSize)throw Error("T2 Polynomial is not well calculated");delete p.T2,delete p.T2z,delete y.T2z}async function l(){let t=new eC(3,d,a);if(t.addPolynomial(0,y.Z),t.addPolynomial(1,y.T1),t.addPolynomial(2,y.T2),y.C2=t.getPolynomial(),y.C2.degree()>=9*u.domainSize)throw Error("C2 Polynomial is not well calculated")}}async function P(){a&&a.info("> Computing challenge xi");let t=new er(d);t.addScalar(x.gamma),t.addPolCommitment(F.getPolynomial("C2")),x.xiSeed=t.getChallenge();let e=f.square(x.xiSeed);C.w8=[],C.w8[0]=f.one;for(let t=1;t<8;t++)C.w8[t]=f.mul(C.w8[t-1],u.w8);C.w4=[],C.w4[0]=f.one;for(let t=1;t<4;t++)C.w4[t]=f.mul(C.w4[t-1],u.w4);C.w3=[],C.w3[0]=f.one,C.w3[1]=u.w3,C.w3[2]=f.square(u.w3),C.S0={},C.S0.h0w8=[],C.S0.h0w8[0]=f.mul(e,x.xiSeed);for(let t=1;t<8;t++)C.S0.h0w8[t]=f.mul(C.S0.h0w8[0],C.w8[t]);C.S1={},C.S1.h1w4=[],C.S1.h1w4[0]=f.square(C.S0.h0w8[0]);for(let t=1;t<4;t++)C.S1.h1w4[t]=f.mul(C.S1.h1w4[0],C.w4[t]);C.S2={},C.S2.h2w3=[],C.S2.h2w3[0]=f.mul(C.S1.h1w4[0],e),C.S2.h2w3[1]=f.mul(C.S2.h2w3[0],C.w3[1]),C.S2.h2w3[2]=f.mul(C.S2.h2w3[0],C.w3[2]),C.S2.h3w3=[],C.S2.h3w3[0]=f.mul(C.S2.h2w3[0],u.wr),C.S2.h3w3[1]=f.mul(C.S2.h3w3[0],C.w3[1]),C.S2.h3w3[2]=f.mul(C.S2.h3w3[0],C.w3[2]),x.xi=f.mul(f.square(C.S2.h2w3[0]),C.S2.h2w3[0]),a&&a.info("\xb7\xb7\xb7 challenges.xi: "+f.toString(x.xi)),y.QL=new el(new n.BigBuffer(h),d,a),y.QR=new el(new n.BigBuffer(h),d,a),y.QM=new el(new n.BigBuffer(h),d,a),y.QO=new el(new n.BigBuffer(h),d,a),y.QC=new el(new n.BigBuffer(h),d,a),await l.readToBuffer(y.QL.coef,0,h,s[7][0].p),await l.readToBuffer(y.QR.coef,0,h,s[8][0].p),await l.readToBuffer(y.QM.coef,0,h,s[9][0].p),await l.readToBuffer(y.QO.coef,0,h,s[10][0].p),await l.readToBuffer(y.QC.coef,0,h,s[11][0].p),a&&a.info("\xb7\xb7\xb7 Computing evaluations"),F.addEvaluation("ql",y.QL.evaluate(x.xi)),F.addEvaluation("qr",y.QR.evaluate(x.xi)),F.addEvaluation("qm",y.QM.evaluate(x.xi)),F.addEvaluation("qo",y.QO.evaluate(x.xi)),F.addEvaluation("qc",y.QC.evaluate(x.xi)),F.addEvaluation("s1",y.Sigma1.evaluate(x.xi)),F.addEvaluation("s2",y.Sigma2.evaluate(x.xi)),F.addEvaluation("s3",y.Sigma3.evaluate(x.xi)),F.addEvaluation("a",y.A.evaluate(x.xi)),F.addEvaluation("b",y.B.evaluate(x.xi)),F.addEvaluation("c",y.C.evaluate(x.xi)),F.addEvaluation("z",y.Z.evaluate(x.xi)),x.xiw=f.mul(x.xi,f.w[u.power]),F.addEvaluation("zw",y.Z.evaluate(x.xiw)),F.addEvaluation("t1w",y.T1.evaluate(x.xiw)),F.addEvaluation("t2w",y.T2.evaluate(x.xiw))}async function R(){a&&a.info("> Computing challenge alpha");let t=new er(d);t.addScalar(x.xiSeed),t.addScalar(F.getEvaluation("ql")),t.addScalar(F.getEvaluation("qr")),t.addScalar(F.getEvaluation("qm")),t.addScalar(F.getEvaluation("qo")),t.addScalar(F.getEvaluation("qc")),t.addScalar(F.getEvaluation("s1")),t.addScalar(F.getEvaluation("s2")),t.addScalar(F.getEvaluation("s3")),t.addScalar(F.getEvaluation("a")),t.addScalar(F.getEvaluation("b")),t.addScalar(F.getEvaluation("c")),t.addScalar(F.getEvaluation("z")),t.addScalar(F.getEvaluation("zw")),t.addScalar(F.getEvaluation("t1w")),t.addScalar(F.getEvaluation("t2w")),x.alpha=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.alpha: "+f.toString(x.alpha)),a&&a.info("> Reading C0 polynomial"),y.C0=new el(new n.BigBuffer(8*h),d,a),await l.readToBuffer(y.C0.coef,0,8*h,s[17][0].p),a&&a.info("> Computing R0 polynomial"),function(){if(y.R0=el.lagrangePolynomialInterpolation([C.S0.h0w8[0],C.S0.h0w8[1],C.S0.h0w8[2],C.S0.h0w8[3],C.S0.h0w8[4],C.S0.h0w8[5],C.S0.h0w8[6],C.S0.h0w8[7]],[y.C0.evaluate(C.S0.h0w8[0]),y.C0.evaluate(C.S0.h0w8[1]),y.C0.evaluate(C.S0.h0w8[2]),y.C0.evaluate(C.S0.h0w8[3]),y.C0.evaluate(C.S0.h0w8[4]),y.C0.evaluate(C.S0.h0w8[5]),y.C0.evaluate(C.S0.h0w8[6]),y.C0.evaluate(C.S0.h0w8[7])],d),y.R0.degree()>7)throw Error("R0 Polynomial is not well calculated")}(),a&&a.info("> Computing R1 polynomial"),function(){if(y.R1=el.lagrangePolynomialInterpolation([C.S1.h1w4[0],C.S1.h1w4[1],C.S1.h1w4[2],C.S1.h1w4[3]],[y.C1.evaluate(C.S1.h1w4[0]),y.C1.evaluate(C.S1.h1w4[1]),y.C1.evaluate(C.S1.h1w4[2]),y.C1.evaluate(C.S1.h1w4[3])],d),y.R1.degree()>3)throw Error("R1 Polynomial is not well calculated")}(),a&&a.info("> Computing R2 polynomial"),function(){if(y.R2=el.lagrangePolynomialInterpolation([C.S2.h2w3[0],C.S2.h2w3[1],C.S2.h2w3[2],C.S2.h3w3[0],C.S2.h3w3[1],C.S2.h3w3[2]],[y.C2.evaluate(C.S2.h2w3[0]),y.C2.evaluate(C.S2.h2w3[1]),y.C2.evaluate(C.S2.h2w3[2]),y.C2.evaluate(C.S2.h3w3[0]),y.C2.evaluate(C.S2.h3w3[1]),y.C2.evaluate(C.S2.h3w3[2])],d),y.R2.degree()>5)throw Error("R2 Polynomial is not well calculated")}(),a&&a.info("> Computing F polynomial"),await i(),a&&a.info("> Computing W1 multi exponentiation");let e=await y.F.multiExponentiation(E,"W1");return F.addPolynomial("W1",e),0;async function i(){a&&a.info("\xb7\xb7\xb7 Computing F polynomial"),y.F=el.fromPolynomial(y.C0,d,a),y.F.sub(y.R0),y.F.divByZerofier(8,x.xi);let t=el.fromPolynomial(y.C1,d,a);t.sub(y.R1),t.mulScalar(x.alpha),t.divByZerofier(4,x.xi);let e=el.fromPolynomial(y.C2,d,a);if(e.sub(y.R2),e.mulScalar(f.square(x.alpha)),e.divByZerofier(3,x.xi),e.divByZerofier(3,x.xiw),y.F.add(t),y.F.add(e),y.F.degree()>=9*u.domainSize-6)throw Error("F Polynomial is not well calculated")}}async function U(){a&&a.info("> Computing challenge y");let t=new er(d);t.addScalar(x.alpha),t.addPolCommitment(F.getPolynomial("W1")),x.y=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.y: "+f.toString(x.y)),a&&a.info("> Computing L polynomial"),await o(),a&&a.info("> Computing ZTS2 polynomial"),await s();let e=y.ZTS2.evaluate(x.y);e=f.inv(e),y.L.mulScalar(e);let i=el.fromCoefficientsArray([f.neg(x.y),f.one],d);a&&a.info("> Computing W' = L / ZTS2 polynomial");let n=y.L.divBy(i);if(n.degree()>0)throw Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${n.degree()} and should be 0`);if(y.L.degree()>=9*u.domainSize-1)throw Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");a&&a.info("> Computing W' multi exponentiation");let r=await y.L.multiExponentiation(E,"W2");return F.addPolynomial("W2",r),0;async function o(){a&&a.info("\xb7\xb7\xb7 Computing L polynomial");let t=y.R0.evaluate(x.y),e=y.R1.evaluate(x.y),i=y.R2.evaluate(x.y),n=f.sub(x.y,C.S0.h0w8[0]);for(let t=1;t<8;t++)n=f.mul(n,f.sub(x.y,C.S0.h0w8[t]));let r=f.sub(x.y,C.S1.h1w4[0]);for(let t=1;t<4;t++)r=f.mul(r,f.sub(x.y,C.S1.h1w4[t]));let o=f.sub(x.y,C.S2.h2w3[0]);for(let t=1;t<3;t++)o=f.mul(o,f.sub(x.y,C.S2.h2w3[t]));for(let t=0;t<3;t++)o=f.mul(o,f.sub(x.y,C.S2.h3w3[t]));let s=f.mul(r,o),c=f.mul(x.alpha,f.mul(n,o)),w=f.mul(f.square(x.alpha),f.mul(n,r));v.denH1=r,v.denH2=o,y.L=el.fromPolynomial(y.C0,d,a),y.L.subScalar(t),y.L.mulScalar(s);let g=el.fromPolynomial(y.C1,d,a);g.subScalar(e),g.mulScalar(c);let h=el.fromPolynomial(y.C2,d,a);h.subScalar(i),h.mulScalar(w),y.L.add(g),y.L.add(h),a&&a.info("> Computing ZT polynomial"),await l();let m=y.ZT.evaluate(x.y);if(y.F.mulScalar(m),y.L.sub(y.F),y.L.degree()>=9*u.domainSize)throw Error("L Polynomial is not well calculated");delete p.L}async function l(){y.ZT=el.zerofierPolynomial([C.S0.h0w8[0],C.S0.h0w8[1],C.S0.h0w8[2],C.S0.h0w8[3],C.S0.h0w8[4],C.S0.h0w8[5],C.S0.h0w8[6],C.S0.h0w8[7],C.S1.h1w4[0],C.S1.h1w4[1],C.S1.h1w4[2],C.S1.h1w4[3],C.S2.h2w3[0],C.S2.h2w3[1],C.S2.h2w3[2],C.S2.h3w3[0],C.S2.h3w3[1],C.S2.h3w3[2]],d)}async function s(){y.ZTS2=el.zerofierPolynomial([C.S1.h1w4[0],C.S1.h1w4[1],C.S1.h1w4[2],C.S1.h1w4[3],C.S2.h2w3[0],C.S2.h2w3[1],C.S2.h2w3[2],C.S2.h3w3[0],C.S2.h3w3[1],C.S2.h3w3[2]],d)}}}let{unstringifyBigInts:eB}=n.utils;async function e_(t,e,a,i){let n=eB(t),r={type:"mem"};return await td(n,e,r),await eG(a,r,i)}let{unstringifyBigInts:eT}=n.utils;async function eL(t,e,a,i){i&&i.info("FFLONK VERIFIER STARTED"),t=eT(t),a=eT(a);let n=await G(t.curve),r=function(t,e){let a=e;return a.k1=t.Fr.fromObject(e.k1),a.k2=t.Fr.fromObject(e.k2),a.w=t.Fr.fromObject(e.w),a.w3=t.Fr.fromObject(e.w3),a.w4=t.Fr.fromObject(e.w4),a.w8=t.Fr.fromObject(e.w8),a.wr=t.Fr.fromObject(e.wr),a.X_2=t.G2.fromObject(e.X_2),a.C0=t.G1.fromObject(e.C0),a}(n,t),o=new ei(n,i);o.fromObjectProof(a);let l=eT(e);if(l.length!==r.nPublic)return i.error("Number of public signals does not match with vk"),!1;let s=n.Fr;if(i&&(i.info("----------------------------"),i.info("  FFLONK VERIFY SETTINGS"),i.info(`  Curve:         ${n.name}`),i.info(`  Circuit power: ${r.power}`),i.info(`  Domain size:   ${2**r.power}`),i.info(`  Public vars:   ${r.nPublic}`),i.info("----------------------------")),i&&i.info("> Checking commitments belong to G1"),!function(t,e,a){let i=t.G1;return i.isValid(e.polynomials.C1)&&i.isValid(e.polynomials.C2)&&i.isValid(e.polynomials.W1)&&i.isValid(e.polynomials.W2)&&i.isValid(a.C0)}(n,o,r))return i&&i.error("Proof commitments are not valid"),!1;if(i&&i.info("> Checking evaluations belong to F"),!(ez(n,o.evaluations.ql)&&ez(n,o.evaluations.qr)&&ez(n,o.evaluations.qm)&&ez(n,o.evaluations.qo)&&ez(n,o.evaluations.qc)&&ez(n,o.evaluations.s1)&&ez(n,o.evaluations.s2)&&ez(n,o.evaluations.s3)&&ez(n,o.evaluations.a)&&ez(n,o.evaluations.b)&&ez(n,o.evaluations.c)&&ez(n,o.evaluations.z)&&ez(n,o.evaluations.zw)&&ez(n,o.evaluations.t1w)&&ez(n,o.evaluations.t2w)))return i&&i.error("Proof evaluations are not valid."),!1;if(i&&i.info("> Checking public inputs belong to F"),!function(t,e){for(let a=0;a<e.length;a++)if(!eA(t,e[a]))return!1;return!0}(n,l))return i&&i.error("Public inputs are not valid."),!1;i&&i.info("> Computing challenges");let{challenges:u,roots:d}=function(t,e,a,i,n){let r=t.Fr,o={},l={},s=new er(t);s.addPolCommitment(a.C0);for(let t=0;t<i.length;t++)s.addScalar(r.e(i[t]));s.addPolCommitment(e.polynomials.C1),o.beta=s.getChallenge(),s.reset(),s.addScalar(o.beta),o.gamma=s.getChallenge(),s.reset(),s.addScalar(o.gamma),s.addPolCommitment(e.polynomials.C2);let u=s.getChallenge(),d=r.square(u),f=[];f[1]=a.w8,f[2]=r.square(a.w8),f[3]=r.mul(f[2],a.w8),f[4]=r.mul(f[3],a.w8),f[5]=r.mul(f[4],a.w8),f[6]=r.mul(f[5],a.w8),f[7]=r.mul(f[6],a.w8);let c=[];c[1]=a.w4,c[2]=r.square(a.w4),c[3]=r.mul(c[2],a.w4);let w=[];w[1]=a.w3,w[2]=r.square(a.w3),l.S0={},l.S0.h0w8=[],l.S0.h0w8[0]=r.mul(d,u);for(let t=1;t<8;t++)l.S0.h0w8[t]=r.mul(l.S0.h0w8[0],f[t]);l.S1={},l.S1.h1w4=[],l.S1.h1w4[0]=r.square(l.S0.h0w8[0]);for(let t=1;t<4;t++)l.S1.h1w4[t]=r.mul(l.S1.h1w4[0],c[t]);l.S2={},l.S2.h2w3=[],l.S2.h2w3[0]=r.mul(l.S1.h1w4[0],d),l.S2.h2w3[1]=r.mul(l.S2.h2w3[0],w[1]),l.S2.h2w3[2]=r.mul(l.S2.h2w3[0],w[2]),l.S2.h3w3=[],l.S2.h3w3[0]=r.mul(l.S2.h2w3[0],a.wr),l.S2.h3w3[1]=r.mul(l.S2.h3w3[0],w[1]),l.S2.h3w3[2]=r.mul(l.S2.h3w3[0],w[2]),o.xi=r.mul(r.square(l.S2.h2w3[0]),l.S2.h2w3[0]),o.xiw=r.mul(o.xi,r.w[a.power]),o.xiN=o.xi,a.domainSize=1;for(let t=0;t<a.power;t++)o.xiN=r.square(o.xiN),a.domainSize*=2;return s.reset(),s.addScalar(u),s.addScalar(e.evaluations.ql),s.addScalar(e.evaluations.qr),s.addScalar(e.evaluations.qm),s.addScalar(e.evaluations.qo),s.addScalar(e.evaluations.qc),s.addScalar(e.evaluations.s1),s.addScalar(e.evaluations.s2),s.addScalar(e.evaluations.s3),s.addScalar(e.evaluations.a),s.addScalar(e.evaluations.b),s.addScalar(e.evaluations.c),s.addScalar(e.evaluations.z),s.addScalar(e.evaluations.zw),s.addScalar(e.evaluations.t1w),s.addScalar(e.evaluations.t2w),o.alpha=s.getChallenge(),s.reset(),s.addScalar(o.alpha),s.addPolCommitment(e.polynomials.W1),o.y=s.getChallenge(),n&&(n.info("\xb7\xb7\xb7 challenges.beta:  "+r.toString(o.beta)),n.info("\xb7\xb7\xb7 challenges.gamma: "+r.toString(o.gamma)),n.info("\xb7\xb7\xb7 challenges.xi:    "+r.toString(o.xi)),n.info("\xb7\xb7\xb7 challenges.alpha: "+r.toString(o.alpha)),n.info("\xb7\xb7\xb7 challenges.y:     "+r.toString(o.y))),{challenges:o,roots:l}}(n,o,r,l,i);i&&i.info("> Computing Zero polynomial evaluation Z_H(xi)"),u.zh=s.sub(u.xiN,s.one),u.invzh=s.inv(u.zh),i&&i.info("> Computing Lagrange evaluations");let f=await eP(n,u,r);i&&i.info("> Computing polynomial identities PI(X)");let c=function(t,e,a){let i=t.Fr,n=i.zero;for(let t=0;t<e.length;t++){let r=i.e(e[t]);n=i.sub(n,i.mul(r,a[t+1]))}return n}(n,l,f);i&&i.info("> Computing r0(y)");let w=function(t,e,a,i,n){let r=i.Fr,o=eU(a.S0.h0w8,e.y,e.xi,i);n&&n.info("\xb7\xb7\xb7 Computing r0(y)");let l=r.zero;for(let e=0;e<8;e++){let i=[];i[1]=a.S0.h0w8[e];for(let t=2;t<8;t++)i[t]=r.mul(i[t-1],a.S0.h0w8[e]);let n=r.add(t.evaluations.ql,r.mul(t.evaluations.qr,i[1]));n=r.add(n,r.mul(t.evaluations.qo,i[2])),n=r.add(n,r.mul(t.evaluations.qm,i[3])),n=r.add(n,r.mul(t.evaluations.qc,i[4])),n=r.add(n,r.mul(t.evaluations.s1,i[5])),n=r.add(n,r.mul(t.evaluations.s2,i[6])),n=r.add(n,r.mul(t.evaluations.s3,i[7])),l=r.add(l,r.mul(n,o[e]))}return l}(o,u,d,n,i);i&&i.info("> Computing r1(y)");let g=function(t,e,a,i,n,r){let o=n.Fr,l=eU(a.S1.h1w4,e.y,e.xi,n);r&&r.info("\xb7\xb7\xb7 Computing T0(xi)");let s=o.mul(t.evaluations.ql,t.evaluations.a);s=o.add(s,o.mul(t.evaluations.qr,t.evaluations.b)),s=o.add(s,o.mul(t.evaluations.qm,o.mul(t.evaluations.a,t.evaluations.b))),s=o.add(s,o.mul(t.evaluations.qo,t.evaluations.c)),s=o.add(s,t.evaluations.qc),s=o.add(s,i),s=o.mul(s,e.invzh),r&&r.info("\xb7\xb7\xb7 Computing C1(h_1_4^i) values");let u=o.zero;for(let e=0;e<4;e++){let i=t.evaluations.a;i=o.add(i,o.mul(a.S1.h1w4[e],t.evaluations.b));let n=o.square(a.S1.h1w4[e]);i=o.add(i,o.mul(n,t.evaluations.c)),i=o.add(i,o.mul(o.mul(n,a.S1.h1w4[e]),s)),u=o.add(u,o.mul(i,l[e]))}return u}(o,u,d,c,n,i);i&&i.info("> Computing r2(y)");let h=function(t,e,a,i,n,r,o){let l=r.Fr,s=function(t,e,a,i,n){let r=n.Fr,o=[],l=t[0].length,s=l*t.length,u=r.exp(e,s),d=r.mul(r.add(a,i),r.exp(e,l)),f=r.mul(a,i),c=r.add(r.sub(u,d),f),w=r.mul(r.mul(r.e(l),t[0][0]),r.sub(a,i));for(let a=0;a<l;a++){let i=t[0][(l-1)*a%l],n=r.sub(e,t[0][a]),s=r.mul(w,r.mul(i,n));o[a]=r.div(c,s)}w=r.mul(r.mul(r.e(l),t[1][0]),r.sub(i,a));for(let a=0;a<l;a++){let i=t[1][(l-1)*a%l],n=r.sub(e,t[1][a]),s=r.mul(w,r.mul(i,n));o[a+l]=r.div(c,s)}return o}([a.S2.h2w3,a.S2.h3w3],e.y,e.xi,e.xiw,r);o&&o.info("\xb7\xb7\xb7 Computing T1(xi)");let u=l.sub(t.evaluations.z,l.one);u=l.mul(u,i),u=l.mul(u,e.invzh),o&&o.info("\xb7\xb7\xb7 Computing T2(xi)");let d=l.mul(e.beta,e.xi),f=l.add(t.evaluations.a,l.add(d,e.gamma)),c=l.add(t.evaluations.b,l.add(l.mul(d,n.k1),e.gamma)),w=l.add(t.evaluations.c,l.add(l.mul(d,n.k2),e.gamma)),g=l.mul(f,l.mul(c,l.mul(w,t.evaluations.z))),h=l.add(t.evaluations.a,l.add(l.mul(e.beta,t.evaluations.s1),e.gamma)),m=l.add(t.evaluations.b,l.add(l.mul(e.beta,t.evaluations.s2),e.gamma)),b=l.add(t.evaluations.c,l.add(l.mul(e.beta,t.evaluations.s3),e.gamma)),p=l.mul(h,l.mul(m,l.mul(b,t.evaluations.zw))),y=l.sub(g,p);y=l.mul(y,e.invzh),o&&o.info("\xb7\xb7\xb7 Computing C2(h_2_3^i) values");let S=l.zero;for(let e=0;e<3;e++){let i=l.add(t.evaluations.z,l.mul(a.S2.h2w3[e],u));i=l.add(i,l.mul(l.square(a.S2.h2w3[e]),y)),S=l.add(S,l.mul(i,s[e]))}o&&o.info("\xb7\xb7\xb7 Computing C2(h_3_3^i) values");for(let e=0;e<3;e++){let i=l.add(t.evaluations.zw,l.mul(a.S2.h3w3[e],t.evaluations.t1w));i=l.add(i,l.mul(l.square(a.S2.h3w3[e]),t.evaluations.t2w)),S=l.add(S,l.mul(i,s[e+3]))}return S}(o,u,d,f[1],r,n,i);i&&i.info("> Computing F");let m=function(t,e,a,i,n){let r=t.G1,o=t.Fr,l=o.sub(i.y,n.S0.h0w8[0]);for(let t=1;t<8;t++)l=o.mul(l,o.sub(i.y,n.S0.h0w8[t]));i.temp=l;let s=o.sub(i.y,n.S1.h1w4[0]);for(let t=1;t<4;t++)s=o.mul(s,o.sub(i.y,n.S1.h1w4[t]));let u=o.sub(i.y,n.S2.h2w3[0]);for(let t=1;t<3;t++)u=o.mul(u,o.sub(i.y,n.S2.h2w3[t]));for(let t=0;t<3;t++)u=o.mul(u,o.sub(i.y,n.S2.h3w3[t]));i.quotient1=o.mul(i.alpha,o.div(l,s)),i.quotient2=o.mul(o.square(i.alpha),o.div(l,u));let d=r.timesFr(e.polynomials.C1,i.quotient1),f=r.timesFr(e.polynomials.C2,i.quotient2);return r.add(a.C0,r.add(d,f))}(n,o,r,u,d);i&&i.info("> Computing E");let b=function(t,e,a,i,n,r,o){let l=t.G1,s=t.Fr,u=s.mul(r,a.quotient1),d=s.mul(o,a.quotient2);return l.timesFr(l.one,s.add(n,s.add(u,d)))}(n,0,u,0,w,g,h);i&&i.info("> Computing J");let p=function(t,e,a){let i=t.G1;return i.timesFr(e.polynomials.W1,a.temp)}(n,o,u);i&&i.info("> Validate all evaluations with a pairing");let y=await eR(n,o,u,r,m,b,p);return i&&(y?i.info("PROOF VERIFIED SUCCESSFULLY"):i.warn("Invalid Proof")),i&&i.info("FFLONK VERIFIER FINISHED"),y}function eA(t,e){return n.Scalar.lt(e,t.r)}function ez(t,e){return eA(t,n.Scalar.fromRprLE(e))}async function eP(t,e,a){let i=t.Fr,r=Math.max(1,a.nPublic),o=new n.BigBuffer(r*i.n8),l=new n.BigBuffer(r*i.n8),s=i.one;for(let t=0;t<r;t++){let n=t*i.n8;o.set(i.mul(s,e.zh),n),l.set(i.mul(i.e(a.domainSize),i.sub(e.xi,s)),n),s=i.mul(s,a.w)}l=await i.batchInverse(l);let u=[];for(let t=0;t<r;t++){let e=t*i.n8;u[t+1]=i.mul(o.slice(e,e+i.n8),l.slice(e,e+i.n8))}return u}async function eR(t,e,a,i,n,r,o){let l=t.G1,s=l.timesFr(e.polynomials.W2,a.y);s=l.add(l.sub(l.sub(n,r),o),s);let u=t.G2.one,d=e.polynomials.W2,f=i.X_2;return await t.pairingEq(l.neg(s),u,d,f)}function eU(t,e,a,i){let n=i.Fr,r=t.length,o=n.sub(n.exp(e,r),a),l=n.mul(n.e(r),n.exp(t[0],r-2)),s=[];for(let a=0;a<r;a++){let i=t[(r-1)*a%r],u=n.sub(e,t[a]);s[a]=n.div(o,n.mul(n.mul(l,i),u))}return s}let{unstringifyBigInts:e$}=n.utils;function ek(t){let e=t.toString(16);for(;e.length<64;)e="0"+e;return`0x${e}`}var eI=Object.freeze({__proto__:null,setup:eF,prove:eG,fullProve:e_,verify:eL,exportSolidityVerifier:t9,exportSolidityCallData:async function(t,e){let a=e$(e),i=e$(t),n=await G(a.curve);n.G1,n.Fr;let r="";for(let t=0;t<i.length;t++)""!==r&&(r+=","),r+=ek(i[t]);return`[${ek(a.polynomials.C1[0])}, ${ek(a.polynomials.C1[1])},${ek(a.polynomials.C2[0])},${ek(a.polynomials.C2[1])},${ek(a.polynomials.W1[0])},${ek(a.polynomials.W1[1])},${ek(a.polynomials.W2[0])},${ek(a.polynomials.W2[1])},${ek(a.evaluations.ql)},${ek(a.evaluations.qr)},${ek(a.evaluations.qm)},${ek(a.evaluations.qo)},${ek(a.evaluations.qc)},${ek(a.evaluations.s1)},${ek(a.evaluations.s2)},${ek(a.evaluations.s3)},${ek(a.evaluations.a)},${ek(a.evaluations.b)},${ek(a.evaluations.c)},${ek(a.evaluations.z)},${ek(a.evaluations.zw)},${ek(a.evaluations.t1w)},${ek(a.evaluations.t2w)},${ek(a.evaluations.inv)}],[${r}]`}});e.fflonk=eI,e.groth16=tb,e.plonk=ep,e.powersOfTau=tk,e.r1cs=tq,e.wtns=tV,e.zKey=ee}}]);